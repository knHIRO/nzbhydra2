package org.nzbhydra.config.category;

import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.internal.Iterables;
import org.assertj.core.util.Objects;

/**
 * Abstract base class for {@link Category} specific assertions - Generated by CustomAssertionGenerator.
 */
@jakarta.annotation.Generated(value = "assertj-assertions-generator")
public abstract class AbstractCategoryAssert<S extends AbstractCategoryAssert<S, A>, A extends Category> extends AbstractObjectAssert<S, A> {

    /**
     * Creates a new <code>{@link AbstractCategoryAssert}</code> to make assertions on actual Category.
     *
     * @param actual the Category we want to make assertions on.
     */
    protected AbstractCategoryAssert(A actual, Class<S> selfType) {
        super(actual, selfType);
    }

    /**
     * Verifies that the actual Category's applyRestrictionsType is equal to the given one.
     *
     * @param applyRestrictionsType the given applyRestrictionsType to compare the actual Category's applyRestrictionsType to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's applyRestrictionsType is not equal to the given one.
     */
    public S hasApplyRestrictionsType(org.nzbhydra.config.SearchSourceRestriction applyRestrictionsType) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting applyRestrictionsType of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        org.nzbhydra.config.SearchSourceRestriction actualApplyRestrictionsType = actual.getApplyRestrictionsType();
        if (!Objects.areEqual(actualApplyRestrictionsType, applyRestrictionsType)) {
            failWithMessage(assertjErrorMessage, actual, applyRestrictionsType, actualApplyRestrictionsType);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category is apply size limits to api.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual Category is not apply size limits to api.
     */
    public S isApplySizeLimitsToApi() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isApplySizeLimitsToApi()) {
            failWithMessage("\nExpecting that actual Category is apply size limits to api but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category is not apply size limits to api.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual Category is apply size limits to api.
     */
    public S isNotApplySizeLimitsToApi() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isApplySizeLimitsToApi()) {
            failWithMessage("\nExpecting that actual Category is not apply size limits to api but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's description is equal to the given one.
     *
     * @param description the given description to compare the actual Category's description to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's description is not equal to the given one.
     */
    public S hasDescription(String description) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting description of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualDescription = actual.getDescription();
        if (!Objects.areEqual(actualDescription, description)) {
            failWithMessage(assertjErrorMessage, actual, description, actualDescription);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's forbiddenRegex is equal to the given one.
     *
     * @param forbiddenRegex the given forbiddenRegex to compare the actual Category's forbiddenRegex to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's forbiddenRegex is not equal to the given one.
     */
    public S hasForbiddenRegex(java.util.Optional forbiddenRegex) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting forbiddenRegex of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualForbiddenRegex = actual.getForbiddenRegex();
        if (!Objects.areEqual(actualForbiddenRegex, forbiddenRegex)) {
            failWithMessage(assertjErrorMessage, actual, forbiddenRegex, actualForbiddenRegex);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's forbiddenWords contains the given String elements.
     *
     * @param forbiddenWords the given elements that should be contained in actual Category's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's forbiddenWords does not contain all given String elements.
     */
    public S hasForbiddenWords(String... forbiddenWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenWords(), forbiddenWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's forbiddenWords contains the given String elements in Collection.
     *
     * @param forbiddenWords the given elements that should be contained in actual Category's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's forbiddenWords does not contain all given String elements.
     */
    public S hasForbiddenWords(java.util.Collection<? extends String> forbiddenWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenWords(), forbiddenWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's forbiddenWords contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param forbiddenWords the given elements that should be contained in actual Category's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's forbiddenWords does not contain all given String elements.
     */
    public S hasOnlyForbiddenWords(String... forbiddenWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenWords(), forbiddenWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's forbiddenWords contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param forbiddenWords the given elements that should be contained in actual Category's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's forbiddenWords does not contain all given String elements.
     */
    public S hasOnlyForbiddenWords(java.util.Collection<? extends String> forbiddenWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenWords(), forbiddenWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's forbiddenWords does not contain the given String elements.
     *
     * @param forbiddenWords the given elements that should not be in actual Category's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's forbiddenWords contains any given String elements.
     */
    public S doesNotHaveForbiddenWords(String... forbiddenWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenWords(), forbiddenWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's forbiddenWords does not contain the given String elements in Collection.
     *
     * @param forbiddenWords the given elements that should not be in actual Category's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's forbiddenWords contains any given String elements.
     */
    public S doesNotHaveForbiddenWords(java.util.Collection<? extends String> forbiddenWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenWords(), forbiddenWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category has no forbiddenWords.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual Category's forbiddenWords is not empty.
     */
    public S hasNoForbiddenWords() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have forbiddenWords but had :\n  <%s>";

        // check
        if (actual.getForbiddenWords().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getForbiddenWords());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual Category's ignoreResultsFrom is equal to the given one.
     *
     * @param ignoreResultsFrom the given ignoreResultsFrom to compare the actual Category's ignoreResultsFrom to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's ignoreResultsFrom is not equal to the given one.
     */
    public S hasIgnoreResultsFrom(org.nzbhydra.config.SearchSourceRestriction ignoreResultsFrom) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting ignoreResultsFrom of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        org.nzbhydra.config.SearchSourceRestriction actualIgnoreResultsFrom = actual.getIgnoreResultsFrom();
        if (!Objects.areEqual(actualIgnoreResultsFrom, ignoreResultsFrom)) {
            failWithMessage(assertjErrorMessage, actual, ignoreResultsFrom, actualIgnoreResultsFrom);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's maxSizePreset is equal to the given one.
     *
     * @param maxSizePreset the given maxSizePreset to compare the actual Category's maxSizePreset to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's maxSizePreset is not equal to the given one.
     */
    public S hasMaxSizePreset(java.util.Optional maxSizePreset) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting maxSizePreset of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualMaxSizePreset = actual.getMaxSizePreset();
        if (!Objects.areEqual(actualMaxSizePreset, maxSizePreset)) {
            failWithMessage(assertjErrorMessage, actual, maxSizePreset, actualMaxSizePreset);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category is may be selected.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual Category is not may be selected.
     */
    public S isMayBeSelected() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isMayBeSelected()) {
            failWithMessage("\nExpecting that actual Category is may be selected but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category is not may be selected.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual Category is may be selected.
     */
    public S isNotMayBeSelected() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isMayBeSelected()) {
            failWithMessage("\nExpecting that actual Category is not may be selected but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's minSizePreset is equal to the given one.
     *
     * @param minSizePreset the given minSizePreset to compare the actual Category's minSizePreset to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's minSizePreset is not equal to the given one.
     */
    public S hasMinSizePreset(java.util.Optional minSizePreset) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting minSizePreset of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualMinSizePreset = actual.getMinSizePreset();
        if (!Objects.areEqual(actualMinSizePreset, minSizePreset)) {
            failWithMessage(assertjErrorMessage, actual, minSizePreset, actualMinSizePreset);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's name is equal to the given one.
     *
     * @param name the given name to compare the actual Category's name to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's name is not equal to the given one.
     */
    public S hasName(String name) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting name of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualName = actual.getName();
        if (!Objects.areEqual(actualName, name)) {
            failWithMessage(assertjErrorMessage, actual, name, actualName);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's newznabCategories contains the given java.util.List elements.
     *
     * @param newznabCategories the given elements that should be contained in actual Category's newznabCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's newznabCategories does not contain all given java.util.List elements.
     */
    public S hasNewznabCategories(java.util.List... newznabCategories) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given java.util.List varargs is not null.
        if (newznabCategories == null) {
            failWithMessage("Expecting newznabCategories parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getNewznabCategories(), newznabCategories);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's newznabCategories contains the given java.util.List elements in Collection.
     *
     * @param newznabCategories the given elements that should be contained in actual Category's newznabCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's newznabCategories does not contain all given java.util.List elements.
     */
    public S hasNewznabCategories(java.util.Collection<? extends java.util.List> newznabCategories) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given java.util.List collection is not null.
        if (newznabCategories == null) {
            failWithMessage("Expecting newznabCategories parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getNewznabCategories(), newznabCategories.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's newznabCategories contains <b>only</b> the given java.util.List elements and nothing else in whatever order.
     *
     * @param newznabCategories the given elements that should be contained in actual Category's newznabCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's newznabCategories does not contain all given java.util.List elements.
     */
    public S hasOnlyNewznabCategories(java.util.List... newznabCategories) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given java.util.List varargs is not null.
        if (newznabCategories == null) {
            failWithMessage("Expecting newznabCategories parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getNewznabCategories(), newznabCategories);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's newznabCategories contains <b>only</b> the given java.util.List elements in Collection and nothing else in whatever order.
     *
     * @param newznabCategories the given elements that should be contained in actual Category's newznabCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's newznabCategories does not contain all given java.util.List elements.
     */
    public S hasOnlyNewznabCategories(java.util.Collection<? extends java.util.List> newznabCategories) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given java.util.List collection is not null.
        if (newznabCategories == null) {
            failWithMessage("Expecting newznabCategories parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getNewznabCategories(), newznabCategories.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's newznabCategories does not contain the given java.util.List elements.
     *
     * @param newznabCategories the given elements that should not be in actual Category's newznabCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's newznabCategories contains any given java.util.List elements.
     */
    public S doesNotHaveNewznabCategories(java.util.List... newznabCategories) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given java.util.List varargs is not null.
        if (newznabCategories == null) {
            failWithMessage("Expecting newznabCategories parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getNewznabCategories(), newznabCategories);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's newznabCategories does not contain the given java.util.List elements in Collection.
     *
     * @param newznabCategories the given elements that should not be in actual Category's newznabCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's newznabCategories contains any given java.util.List elements.
     */
    public S doesNotHaveNewznabCategories(java.util.Collection<? extends java.util.List> newznabCategories) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given java.util.List collection is not null.
        if (newznabCategories == null) {
            failWithMessage("Expecting newznabCategories parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getNewznabCategories(), newznabCategories.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category has no newznabCategories.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual Category's newznabCategories is not empty.
     */
    public S hasNoNewznabCategories() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have newznabCategories but had :\n  <%s>";

        // check
        if (actual.getNewznabCategories().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getNewznabCategories());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual Category is preselect.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual Category is not preselect.
     */
    public S isPreselect() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isPreselect()) {
            failWithMessage("\nExpecting that actual Category is preselect but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category is not preselect.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual Category is preselect.
     */
    public S isNotPreselect() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isPreselect()) {
            failWithMessage("\nExpecting that actual Category is not preselect but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's requiredRegex is equal to the given one.
     *
     * @param requiredRegex the given requiredRegex to compare the actual Category's requiredRegex to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's requiredRegex is not equal to the given one.
     */
    public S hasRequiredRegex(java.util.Optional requiredRegex) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting requiredRegex of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualRequiredRegex = actual.getRequiredRegex();
        if (!Objects.areEqual(actualRequiredRegex, requiredRegex)) {
            failWithMessage(assertjErrorMessage, actual, requiredRegex, actualRequiredRegex);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's requiredWords contains the given String elements.
     *
     * @param requiredWords the given elements that should be contained in actual Category's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's requiredWords does not contain all given String elements.
     */
    public S hasRequiredWords(String... requiredWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getRequiredWords(), requiredWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's requiredWords contains the given String elements in Collection.
     *
     * @param requiredWords the given elements that should be contained in actual Category's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's requiredWords does not contain all given String elements.
     */
    public S hasRequiredWords(java.util.Collection<? extends String> requiredWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getRequiredWords(), requiredWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's requiredWords contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param requiredWords the given elements that should be contained in actual Category's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's requiredWords does not contain all given String elements.
     */
    public S hasOnlyRequiredWords(String... requiredWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getRequiredWords(), requiredWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's requiredWords contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param requiredWords the given elements that should be contained in actual Category's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's requiredWords does not contain all given String elements.
     */
    public S hasOnlyRequiredWords(java.util.Collection<? extends String> requiredWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getRequiredWords(), requiredWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's requiredWords does not contain the given String elements.
     *
     * @param requiredWords the given elements that should not be in actual Category's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's requiredWords contains any given String elements.
     */
    public S doesNotHaveRequiredWords(String... requiredWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getRequiredWords(), requiredWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's requiredWords does not contain the given String elements in Collection.
     *
     * @param requiredWords the given elements that should not be in actual Category's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual Category's requiredWords contains any given String elements.
     */
    public S doesNotHaveRequiredWords(java.util.Collection<? extends String> requiredWords) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getRequiredWords(), requiredWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category has no requiredWords.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual Category's requiredWords is not empty.
     */
    public S hasNoRequiredWords() {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have requiredWords but had :\n  <%s>";

        // check
        if (actual.getRequiredWords().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getRequiredWords());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual Category's searchType is equal to the given one.
     *
     * @param searchType the given searchType to compare the actual Category's searchType to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's searchType is not equal to the given one.
     */
    public S hasSearchType(org.nzbhydra.config.searching.SearchType searchType) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting searchType of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        org.nzbhydra.config.searching.SearchType actualSearchType = actual.getSearchType();
        if (!Objects.areEqual(actualSearchType, searchType)) {
            failWithMessage(assertjErrorMessage, actual, searchType, actualSearchType);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual Category's subtype is equal to the given one.
     *
     * @param subtype the given subtype to compare the actual Category's subtype to.
     * @return this assertion object.
     * @throws AssertionError - if the actual Category's subtype is not equal to the given one.
     */
    public S hasSubtype(Category.Subtype subtype) {
        // check that actual Category we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting subtype of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Category.Subtype actualSubtype = actual.getSubtype();
        if (!Objects.areEqual(actualSubtype, subtype)) {
            failWithMessage(assertjErrorMessage, actual, subtype, actualSubtype);
        }

        // return the current assertion for method chaining
        return myself;
    }

}
