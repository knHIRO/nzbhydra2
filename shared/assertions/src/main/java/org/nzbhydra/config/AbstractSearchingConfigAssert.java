package org.nzbhydra.config;

import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.api.Assertions;
import org.assertj.core.internal.Iterables;
import org.assertj.core.util.Objects;

/**
 * Abstract base class for {@link SearchingConfig} specific assertions - Generated by CustomAssertionGenerator.
 */
@jakarta.annotation.Generated(value = "assertj-assertions-generator")
public abstract class AbstractSearchingConfigAssert<S extends AbstractSearchingConfigAssert<S, A>, A extends SearchingConfig> extends AbstractObjectAssert<S, A> {

    /**
     * Creates a new <code>{@link AbstractSearchingConfigAssert}</code> to make assertions on actual SearchingConfig.
     *
     * @param actual the SearchingConfig we want to make assertions on.
     */
    protected AbstractSearchingConfigAssert(A actual, Class<S> selfType) {
        super(actual, selfType);
    }

    /**
     * Verifies that the actual SearchingConfig's alwaysConvertIds is equal to the given one.
     *
     * @param alwaysConvertIds the given alwaysConvertIds to compare the actual SearchingConfig's alwaysConvertIds to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's alwaysConvertIds is not equal to the given one.
     */
    public S hasAlwaysConvertIds(SearchSourceRestriction alwaysConvertIds) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting alwaysConvertIds of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        SearchSourceRestriction actualAlwaysConvertIds = actual.getAlwaysConvertIds();
        if (!Objects.areEqual(actualAlwaysConvertIds, alwaysConvertIds)) {
            failWithMessage(assertjErrorMessage, actual, alwaysConvertIds, actualAlwaysConvertIds);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is always show quick filter buttons.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not always show quick filter buttons.
     */
    public S isAlwaysShowQuickFilterButtons() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isAlwaysShowQuickFilterButtons()) {
            failWithMessage("\nExpecting that actual SearchingConfig is always show quick filter buttons but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not always show quick filter buttons.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is always show quick filter buttons.
     */
    public S isNotAlwaysShowQuickFilterButtons() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isAlwaysShowQuickFilterButtons()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not always show quick filter buttons but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's applyRestrictions is equal to the given one.
     *
     * @param applyRestrictions the given applyRestrictions to compare the actual SearchingConfig's applyRestrictions to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's applyRestrictions is not equal to the given one.
     */
    public S hasApplyRestrictions(SearchSourceRestriction applyRestrictions) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting applyRestrictions of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        SearchSourceRestriction actualApplyRestrictions = actual.getApplyRestrictions();
        if (!Objects.areEqual(actualApplyRestrictions, applyRestrictions)) {
            failWithMessage(assertjErrorMessage, actual, applyRestrictions, actualApplyRestrictions);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's coverSize is equal to the given one.
     *
     * @param coverSize the given coverSize to compare the actual SearchingConfig's coverSize to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's coverSize is not equal to the given one.
     */
    public S hasCoverSize(int coverSize) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting coverSize of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualCoverSize = actual.getCoverSize();
        if (actualCoverSize != coverSize) {
            failWithMessage(assertjErrorMessage, actual, coverSize, actualCoverSize);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customMappings contains the given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     *
     * @param customMappings the given elements that should be contained in actual SearchingConfig's customMappings.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customMappings does not contain all given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     */
    public S hasCustomMappings(org.nzbhydra.config.searching.CustomQueryAndTitleMapping... customMappings) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.searching.CustomQueryAndTitleMapping varargs is not null.
        if (customMappings == null) {
            failWithMessage("Expecting customMappings parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getCustomMappings(), customMappings);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customMappings contains the given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements in Collection.
     *
     * @param customMappings the given elements that should be contained in actual SearchingConfig's customMappings.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customMappings does not contain all given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     */
    public S hasCustomMappings(java.util.Collection<? extends org.nzbhydra.config.searching.CustomQueryAndTitleMapping> customMappings) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.searching.CustomQueryAndTitleMapping collection is not null.
        if (customMappings == null) {
            failWithMessage("Expecting customMappings parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getCustomMappings(), customMappings.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customMappings contains <b>only</b> the given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements and nothing else in whatever order.
     *
     * @param customMappings the given elements that should be contained in actual SearchingConfig's customMappings.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customMappings does not contain all given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     */
    public S hasOnlyCustomMappings(org.nzbhydra.config.searching.CustomQueryAndTitleMapping... customMappings) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.searching.CustomQueryAndTitleMapping varargs is not null.
        if (customMappings == null) {
            failWithMessage("Expecting customMappings parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getCustomMappings(), customMappings);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customMappings contains <b>only</b> the given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements in Collection and nothing else in whatever order.
     *
     * @param customMappings the given elements that should be contained in actual SearchingConfig's customMappings.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customMappings does not contain all given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     */
    public S hasOnlyCustomMappings(java.util.Collection<? extends org.nzbhydra.config.searching.CustomQueryAndTitleMapping> customMappings) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.searching.CustomQueryAndTitleMapping collection is not null.
        if (customMappings == null) {
            failWithMessage("Expecting customMappings parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getCustomMappings(), customMappings.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customMappings does not contain the given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     *
     * @param customMappings the given elements that should not be in actual SearchingConfig's customMappings.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customMappings contains any given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     */
    public S doesNotHaveCustomMappings(org.nzbhydra.config.searching.CustomQueryAndTitleMapping... customMappings) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.searching.CustomQueryAndTitleMapping varargs is not null.
        if (customMappings == null) {
            failWithMessage("Expecting customMappings parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getCustomMappings(), customMappings);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customMappings does not contain the given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements in Collection.
     *
     * @param customMappings the given elements that should not be in actual SearchingConfig's customMappings.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customMappings contains any given org.nzbhydra.config.searching.CustomQueryAndTitleMapping elements.
     */
    public S doesNotHaveCustomMappings(java.util.Collection<? extends org.nzbhydra.config.searching.CustomQueryAndTitleMapping> customMappings) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.searching.CustomQueryAndTitleMapping collection is not null.
        if (customMappings == null) {
            failWithMessage("Expecting customMappings parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getCustomMappings(), customMappings.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no customMappings.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customMappings is not empty.
     */
    public S hasNoCustomMappings() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have customMappings but had :\n  <%s>";

        // check
        if (actual.getCustomMappings().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getCustomMappings());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig's customQuickFilterButtons contains the given String elements.
     *
     * @param customQuickFilterButtons the given elements that should be contained in actual SearchingConfig's customQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customQuickFilterButtons does not contain all given String elements.
     */
    public S hasCustomQuickFilterButtons(String... customQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (customQuickFilterButtons == null) {
            failWithMessage("Expecting customQuickFilterButtons parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getCustomQuickFilterButtons(), customQuickFilterButtons);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customQuickFilterButtons contains the given String elements in Collection.
     *
     * @param customQuickFilterButtons the given elements that should be contained in actual SearchingConfig's customQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customQuickFilterButtons does not contain all given String elements.
     */
    public S hasCustomQuickFilterButtons(java.util.Collection<? extends String> customQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (customQuickFilterButtons == null) {
            failWithMessage("Expecting customQuickFilterButtons parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getCustomQuickFilterButtons(), customQuickFilterButtons.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customQuickFilterButtons contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param customQuickFilterButtons the given elements that should be contained in actual SearchingConfig's customQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customQuickFilterButtons does not contain all given String elements.
     */
    public S hasOnlyCustomQuickFilterButtons(String... customQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (customQuickFilterButtons == null) {
            failWithMessage("Expecting customQuickFilterButtons parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getCustomQuickFilterButtons(), customQuickFilterButtons);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customQuickFilterButtons contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param customQuickFilterButtons the given elements that should be contained in actual SearchingConfig's customQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customQuickFilterButtons does not contain all given String elements.
     */
    public S hasOnlyCustomQuickFilterButtons(java.util.Collection<? extends String> customQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (customQuickFilterButtons == null) {
            failWithMessage("Expecting customQuickFilterButtons parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getCustomQuickFilterButtons(), customQuickFilterButtons.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customQuickFilterButtons does not contain the given String elements.
     *
     * @param customQuickFilterButtons the given elements that should not be in actual SearchingConfig's customQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customQuickFilterButtons contains any given String elements.
     */
    public S doesNotHaveCustomQuickFilterButtons(String... customQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (customQuickFilterButtons == null) {
            failWithMessage("Expecting customQuickFilterButtons parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getCustomQuickFilterButtons(), customQuickFilterButtons);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's customQuickFilterButtons does not contain the given String elements in Collection.
     *
     * @param customQuickFilterButtons the given elements that should not be in actual SearchingConfig's customQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customQuickFilterButtons contains any given String elements.
     */
    public S doesNotHaveCustomQuickFilterButtons(java.util.Collection<? extends String> customQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (customQuickFilterButtons == null) {
            failWithMessage("Expecting customQuickFilterButtons parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getCustomQuickFilterButtons(), customQuickFilterButtons.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no customQuickFilterButtons.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's customQuickFilterButtons is not empty.
     */
    public S hasNoCustomQuickFilterButtons() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have customQuickFilterButtons but had :\n  <%s>";

        // check
        if (actual.getCustomQuickFilterButtons().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getCustomQuickFilterButtons());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig's duplicateAgeThreshold is equal to the given one.
     *
     * @param duplicateAgeThreshold the given duplicateAgeThreshold to compare the actual SearchingConfig's duplicateAgeThreshold to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's duplicateAgeThreshold is not equal to the given one.
     */
    public S hasDuplicateAgeThreshold(float duplicateAgeThreshold) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting duplicateAgeThreshold of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check value for duplicateAgeThreshold
        float actualDuplicateAgeThreshold = actual.getDuplicateAgeThreshold();
        if (actualDuplicateAgeThreshold != duplicateAgeThreshold) {
            failWithMessage(assertjErrorMessage, actual, duplicateAgeThreshold, actualDuplicateAgeThreshold);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's duplicateAgeThreshold is close to the given value by less than the given offset.
     * <p>
     * If difference is equal to the offset value, assertion is considered successful.
     *
     * @param duplicateAgeThreshold the value to compare the actual SearchingConfig's duplicateAgeThreshold to.
     * @param assertjOffset         the given offset.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's duplicateAgeThreshold is not close enough to the given value.
     */
    public S hasDuplicateAgeThresholdCloseTo(float duplicateAgeThreshold, float assertjOffset) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        float actualDuplicateAgeThreshold = actual.getDuplicateAgeThreshold();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = String.format("\nExpecting duplicateAgeThreshold:\n  <%s>\nto be close to:\n  <%s>\nby less than <%s> but difference was <%s>",
            actualDuplicateAgeThreshold, duplicateAgeThreshold, assertjOffset, Math.abs(duplicateAgeThreshold - actualDuplicateAgeThreshold));

        // check
        Assertions.assertThat(actualDuplicateAgeThreshold).overridingErrorMessage(assertjErrorMessage).isCloseTo(duplicateAgeThreshold, Assertions.within(assertjOffset));

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's duplicateSizeThresholdInPercent is equal to the given one.
     *
     * @param duplicateSizeThresholdInPercent the given duplicateSizeThresholdInPercent to compare the actual SearchingConfig's duplicateSizeThresholdInPercent to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's duplicateSizeThresholdInPercent is not equal to the given one.
     */
    public S hasDuplicateSizeThresholdInPercent(float duplicateSizeThresholdInPercent) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting duplicateSizeThresholdInPercent of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check value for duplicateSizeThresholdInPercent
        float actualDuplicateSizeThresholdInPercent = actual.getDuplicateSizeThresholdInPercent();
        if (actualDuplicateSizeThresholdInPercent != duplicateSizeThresholdInPercent) {
            failWithMessage(assertjErrorMessage, actual, duplicateSizeThresholdInPercent, actualDuplicateSizeThresholdInPercent);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's duplicateSizeThresholdInPercent is close to the given value by less than the given offset.
     * <p>
     * If difference is equal to the offset value, assertion is considered successful.
     *
     * @param duplicateSizeThresholdInPercent the value to compare the actual SearchingConfig's duplicateSizeThresholdInPercent to.
     * @param assertjOffset                   the given offset.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's duplicateSizeThresholdInPercent is not close enough to the given value.
     */
    public S hasDuplicateSizeThresholdInPercentCloseTo(float duplicateSizeThresholdInPercent, float assertjOffset) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        float actualDuplicateSizeThresholdInPercent = actual.getDuplicateSizeThresholdInPercent();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = String.format("\nExpecting duplicateSizeThresholdInPercent:\n  <%s>\nto be close to:\n  <%s>\nby less than <%s> but difference was <%s>",
            actualDuplicateSizeThresholdInPercent, duplicateSizeThresholdInPercent, assertjOffset, Math.abs(duplicateSizeThresholdInPercent - actualDuplicateSizeThresholdInPercent));

        // check
        Assertions.assertThat(actualDuplicateSizeThresholdInPercent).overridingErrorMessage(assertjErrorMessage).isCloseTo(duplicateSizeThresholdInPercent, Assertions.within(assertjOffset));

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenGroups contains the given String elements.
     *
     * @param forbiddenGroups the given elements that should be contained in actual SearchingConfig's forbiddenGroups.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenGroups does not contain all given String elements.
     */
    public S hasForbiddenGroups(String... forbiddenGroups) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenGroups == null) {
            failWithMessage("Expecting forbiddenGroups parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenGroups(), forbiddenGroups);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenGroups contains the given String elements in Collection.
     *
     * @param forbiddenGroups the given elements that should be contained in actual SearchingConfig's forbiddenGroups.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenGroups does not contain all given String elements.
     */
    public S hasForbiddenGroups(java.util.Collection<? extends String> forbiddenGroups) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenGroups == null) {
            failWithMessage("Expecting forbiddenGroups parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenGroups(), forbiddenGroups.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenGroups contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param forbiddenGroups the given elements that should be contained in actual SearchingConfig's forbiddenGroups.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenGroups does not contain all given String elements.
     */
    public S hasOnlyForbiddenGroups(String... forbiddenGroups) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenGroups == null) {
            failWithMessage("Expecting forbiddenGroups parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenGroups(), forbiddenGroups);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenGroups contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param forbiddenGroups the given elements that should be contained in actual SearchingConfig's forbiddenGroups.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenGroups does not contain all given String elements.
     */
    public S hasOnlyForbiddenGroups(java.util.Collection<? extends String> forbiddenGroups) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenGroups == null) {
            failWithMessage("Expecting forbiddenGroups parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenGroups(), forbiddenGroups.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenGroups does not contain the given String elements.
     *
     * @param forbiddenGroups the given elements that should not be in actual SearchingConfig's forbiddenGroups.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenGroups contains any given String elements.
     */
    public S doesNotHaveForbiddenGroups(String... forbiddenGroups) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenGroups == null) {
            failWithMessage("Expecting forbiddenGroups parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenGroups(), forbiddenGroups);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenGroups does not contain the given String elements in Collection.
     *
     * @param forbiddenGroups the given elements that should not be in actual SearchingConfig's forbiddenGroups.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenGroups contains any given String elements.
     */
    public S doesNotHaveForbiddenGroups(java.util.Collection<? extends String> forbiddenGroups) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenGroups == null) {
            failWithMessage("Expecting forbiddenGroups parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenGroups(), forbiddenGroups.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no forbiddenGroups.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenGroups is not empty.
     */
    public S hasNoForbiddenGroups() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have forbiddenGroups but had :\n  <%s>";

        // check
        if (actual.getForbiddenGroups().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getForbiddenGroups());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig's forbiddenPosters contains the given String elements.
     *
     * @param forbiddenPosters the given elements that should be contained in actual SearchingConfig's forbiddenPosters.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenPosters does not contain all given String elements.
     */
    public S hasForbiddenPosters(String... forbiddenPosters) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenPosters == null) {
            failWithMessage("Expecting forbiddenPosters parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenPosters(), forbiddenPosters);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenPosters contains the given String elements in Collection.
     *
     * @param forbiddenPosters the given elements that should be contained in actual SearchingConfig's forbiddenPosters.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenPosters does not contain all given String elements.
     */
    public S hasForbiddenPosters(java.util.Collection<? extends String> forbiddenPosters) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenPosters == null) {
            failWithMessage("Expecting forbiddenPosters parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenPosters(), forbiddenPosters.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenPosters contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param forbiddenPosters the given elements that should be contained in actual SearchingConfig's forbiddenPosters.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenPosters does not contain all given String elements.
     */
    public S hasOnlyForbiddenPosters(String... forbiddenPosters) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenPosters == null) {
            failWithMessage("Expecting forbiddenPosters parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenPosters(), forbiddenPosters);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenPosters contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param forbiddenPosters the given elements that should be contained in actual SearchingConfig's forbiddenPosters.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenPosters does not contain all given String elements.
     */
    public S hasOnlyForbiddenPosters(java.util.Collection<? extends String> forbiddenPosters) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenPosters == null) {
            failWithMessage("Expecting forbiddenPosters parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenPosters(), forbiddenPosters.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenPosters does not contain the given String elements.
     *
     * @param forbiddenPosters the given elements that should not be in actual SearchingConfig's forbiddenPosters.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenPosters contains any given String elements.
     */
    public S doesNotHaveForbiddenPosters(String... forbiddenPosters) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenPosters == null) {
            failWithMessage("Expecting forbiddenPosters parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenPosters(), forbiddenPosters);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenPosters does not contain the given String elements in Collection.
     *
     * @param forbiddenPosters the given elements that should not be in actual SearchingConfig's forbiddenPosters.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenPosters contains any given String elements.
     */
    public S doesNotHaveForbiddenPosters(java.util.Collection<? extends String> forbiddenPosters) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenPosters == null) {
            failWithMessage("Expecting forbiddenPosters parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenPosters(), forbiddenPosters.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no forbiddenPosters.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenPosters is not empty.
     */
    public S hasNoForbiddenPosters() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have forbiddenPosters but had :\n  <%s>";

        // check
        if (actual.getForbiddenPosters().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getForbiddenPosters());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig's forbiddenRegex is equal to the given one.
     *
     * @param forbiddenRegex the given forbiddenRegex to compare the actual SearchingConfig's forbiddenRegex to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's forbiddenRegex is not equal to the given one.
     */
    public S hasForbiddenRegex(java.util.Optional forbiddenRegex) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting forbiddenRegex of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualForbiddenRegex = actual.getForbiddenRegex();
        if (!Objects.areEqual(actualForbiddenRegex, forbiddenRegex)) {
            failWithMessage(assertjErrorMessage, actual, forbiddenRegex, actualForbiddenRegex);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenWords contains the given String elements.
     *
     * @param forbiddenWords the given elements that should be contained in actual SearchingConfig's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenWords does not contain all given String elements.
     */
    public S hasForbiddenWords(String... forbiddenWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenWords(), forbiddenWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenWords contains the given String elements in Collection.
     *
     * @param forbiddenWords the given elements that should be contained in actual SearchingConfig's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenWords does not contain all given String elements.
     */
    public S hasForbiddenWords(java.util.Collection<? extends String> forbiddenWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getForbiddenWords(), forbiddenWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenWords contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param forbiddenWords the given elements that should be contained in actual SearchingConfig's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenWords does not contain all given String elements.
     */
    public S hasOnlyForbiddenWords(String... forbiddenWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenWords(), forbiddenWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenWords contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param forbiddenWords the given elements that should be contained in actual SearchingConfig's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenWords does not contain all given String elements.
     */
    public S hasOnlyForbiddenWords(java.util.Collection<? extends String> forbiddenWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getForbiddenWords(), forbiddenWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenWords does not contain the given String elements.
     *
     * @param forbiddenWords the given elements that should not be in actual SearchingConfig's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenWords contains any given String elements.
     */
    public S doesNotHaveForbiddenWords(String... forbiddenWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenWords(), forbiddenWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's forbiddenWords does not contain the given String elements in Collection.
     *
     * @param forbiddenWords the given elements that should not be in actual SearchingConfig's forbiddenWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenWords contains any given String elements.
     */
    public S doesNotHaveForbiddenWords(java.util.Collection<? extends String> forbiddenWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (forbiddenWords == null) {
            failWithMessage("Expecting forbiddenWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getForbiddenWords(), forbiddenWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no forbiddenWords.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's forbiddenWords is not empty.
     */
    public S hasNoForbiddenWords() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have forbiddenWords but had :\n  <%s>";

        // check
        if (actual.getForbiddenWords().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getForbiddenWords());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig's generateQueries is equal to the given one.
     *
     * @param generateQueries the given generateQueries to compare the actual SearchingConfig's generateQueries to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's generateQueries is not equal to the given one.
     */
    public S hasGenerateQueries(SearchSourceRestriction generateQueries) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting generateQueries of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        SearchSourceRestriction actualGenerateQueries = actual.getGenerateQueries();
        if (!Objects.areEqual(actualGenerateQueries, generateQueries)) {
            failWithMessage(assertjErrorMessage, actual, generateQueries, actualGenerateQueries);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's generateQueriesFormat is equal to the given one.
     *
     * @param generateQueriesFormat the given generateQueriesFormat to compare the actual SearchingConfig's generateQueriesFormat to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's generateQueriesFormat is not equal to the given one.
     */
    public S hasGenerateQueriesFormat(org.nzbhydra.config.indexer.QueryFormat generateQueriesFormat) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting generateQueriesFormat of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        org.nzbhydra.config.indexer.QueryFormat actualGenerateQueriesFormat = actual.getGenerateQueriesFormat();
        if (!Objects.areEqual(actualGenerateQueriesFormat, generateQueriesFormat)) {
            failWithMessage(assertjErrorMessage, actual, generateQueriesFormat, actualGenerateQueriesFormat);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's globalCacheTimeMinutes is equal to the given one.
     *
     * @param globalCacheTimeMinutes the given globalCacheTimeMinutes to compare the actual SearchingConfig's globalCacheTimeMinutes to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's globalCacheTimeMinutes is not equal to the given one.
     */
    public S hasGlobalCacheTimeMinutes(java.util.Optional globalCacheTimeMinutes) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting globalCacheTimeMinutes of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualGlobalCacheTimeMinutes = actual.getGlobalCacheTimeMinutes();
        if (!Objects.areEqual(actualGlobalCacheTimeMinutes, globalCacheTimeMinutes)) {
            failWithMessage(assertjErrorMessage, actual, globalCacheTimeMinutes, actualGlobalCacheTimeMinutes);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's idFallbackToQueryGeneration is equal to the given one.
     *
     * @param idFallbackToQueryGeneration the given idFallbackToQueryGeneration to compare the actual SearchingConfig's idFallbackToQueryGeneration to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's idFallbackToQueryGeneration is not equal to the given one.
     */
    public S hasIdFallbackToQueryGeneration(SearchSourceRestriction idFallbackToQueryGeneration) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting idFallbackToQueryGeneration of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        SearchSourceRestriction actualIdFallbackToQueryGeneration = actual.getIdFallbackToQueryGeneration();
        if (!Objects.areEqual(actualIdFallbackToQueryGeneration, idFallbackToQueryGeneration)) {
            failWithMessage(assertjErrorMessage, actual, idFallbackToQueryGeneration, actualIdFallbackToQueryGeneration);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is ignore load limiting for internal searches.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not ignore load limiting for internal searches.
     */
    public S isIgnoreLoadLimitingForInternalSearches() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isIgnoreLoadLimitingForInternalSearches()) {
            failWithMessage("\nExpecting that actual SearchingConfig is ignore load limiting for internal searches but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not ignore load limiting for internal searches.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is ignore load limiting for internal searches.
     */
    public S isNotIgnoreLoadLimitingForInternalSearches() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isIgnoreLoadLimitingForInternalSearches()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not ignore load limiting for internal searches but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is ignore passworded.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not ignore passworded.
     */
    public S isIgnorePassworded() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isIgnorePassworded()) {
            failWithMessage("\nExpecting that actual SearchingConfig is ignore passworded but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not ignore passworded.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is ignore passworded.
     */
    public S isNotIgnorePassworded() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isIgnorePassworded()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not ignore passworded but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is ignore temporarily disabled.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not ignore temporarily disabled.
     */
    public S isIgnoreTemporarilyDisabled() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isIgnoreTemporarilyDisabled()) {
            failWithMessage("\nExpecting that actual SearchingConfig is ignore temporarily disabled but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not ignore temporarily disabled.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is ignore temporarily disabled.
     */
    public S isNotIgnoreTemporarilyDisabled() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isIgnoreTemporarilyDisabled()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not ignore temporarily disabled but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's keepSearchResultsForDays is equal to the given one.
     *
     * @param keepSearchResultsForDays the given keepSearchResultsForDays to compare the actual SearchingConfig's keepSearchResultsForDays to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's keepSearchResultsForDays is not equal to the given one.
     */
    public S hasKeepSearchResultsForDays(int keepSearchResultsForDays) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting keepSearchResultsForDays of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualKeepSearchResultsForDays = actual.getKeepSearchResultsForDays();
        if (actualKeepSearchResultsForDays != keepSearchResultsForDays) {
            failWithMessage(assertjErrorMessage, actual, keepSearchResultsForDays, actualKeepSearchResultsForDays);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's language is equal to the given one.
     *
     * @param language the given language to compare the actual SearchingConfig's language to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's language is not equal to the given one.
     */
    public S hasLanguage(java.util.Optional language) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting language of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualLanguage = actual.getLanguage();
        if (!Objects.areEqual(actualLanguage, language)) {
            failWithMessage(assertjErrorMessage, actual, language, actualLanguage);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's languagesToKeep contains the given String elements.
     *
     * @param languagesToKeep the given elements that should be contained in actual SearchingConfig's languagesToKeep.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's languagesToKeep does not contain all given String elements.
     */
    public S hasLanguagesToKeep(String... languagesToKeep) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (languagesToKeep == null) {
            failWithMessage("Expecting languagesToKeep parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getLanguagesToKeep(), languagesToKeep);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's languagesToKeep contains the given String elements in Collection.
     *
     * @param languagesToKeep the given elements that should be contained in actual SearchingConfig's languagesToKeep.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's languagesToKeep does not contain all given String elements.
     */
    public S hasLanguagesToKeep(java.util.Collection<? extends String> languagesToKeep) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (languagesToKeep == null) {
            failWithMessage("Expecting languagesToKeep parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getLanguagesToKeep(), languagesToKeep.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's languagesToKeep contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param languagesToKeep the given elements that should be contained in actual SearchingConfig's languagesToKeep.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's languagesToKeep does not contain all given String elements.
     */
    public S hasOnlyLanguagesToKeep(String... languagesToKeep) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (languagesToKeep == null) {
            failWithMessage("Expecting languagesToKeep parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getLanguagesToKeep(), languagesToKeep);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's languagesToKeep contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param languagesToKeep the given elements that should be contained in actual SearchingConfig's languagesToKeep.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's languagesToKeep does not contain all given String elements.
     */
    public S hasOnlyLanguagesToKeep(java.util.Collection<? extends String> languagesToKeep) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (languagesToKeep == null) {
            failWithMessage("Expecting languagesToKeep parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getLanguagesToKeep(), languagesToKeep.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's languagesToKeep does not contain the given String elements.
     *
     * @param languagesToKeep the given elements that should not be in actual SearchingConfig's languagesToKeep.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's languagesToKeep contains any given String elements.
     */
    public S doesNotHaveLanguagesToKeep(String... languagesToKeep) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (languagesToKeep == null) {
            failWithMessage("Expecting languagesToKeep parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getLanguagesToKeep(), languagesToKeep);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's languagesToKeep does not contain the given String elements in Collection.
     *
     * @param languagesToKeep the given elements that should not be in actual SearchingConfig's languagesToKeep.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's languagesToKeep contains any given String elements.
     */
    public S doesNotHaveLanguagesToKeep(java.util.Collection<? extends String> languagesToKeep) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (languagesToKeep == null) {
            failWithMessage("Expecting languagesToKeep parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getLanguagesToKeep(), languagesToKeep.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no languagesToKeep.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's languagesToKeep is not empty.
     */
    public S hasNoLanguagesToKeep() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have languagesToKeep but had :\n  <%s>";

        // check
        if (actual.getLanguagesToKeep().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getLanguagesToKeep());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig is load all cached on internal.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not load all cached on internal.
     */
    public S isLoadAllCachedOnInternal() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isLoadAllCachedOnInternal()) {
            failWithMessage("\nExpecting that actual SearchingConfig is load all cached on internal but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not load all cached on internal.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is load all cached on internal.
     */
    public S isNotLoadAllCachedOnInternal() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isLoadAllCachedOnInternal()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not load all cached on internal but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's loadLimitInternal is equal to the given one.
     *
     * @param loadLimitInternal the given loadLimitInternal to compare the actual SearchingConfig's loadLimitInternal to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's loadLimitInternal is not equal to the given one.
     */
    public S hasLoadLimitInternal(int loadLimitInternal) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting loadLimitInternal of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualLoadLimitInternal = actual.getLoadLimitInternal();
        if (actualLoadLimitInternal != loadLimitInternal) {
            failWithMessage(assertjErrorMessage, actual, loadLimitInternal, actualLoadLimitInternal);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's maxAge is equal to the given one.
     *
     * @param maxAge the given maxAge to compare the actual SearchingConfig's maxAge to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's maxAge is not equal to the given one.
     */
    public S hasMaxAge(java.util.Optional maxAge) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting maxAge of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualMaxAge = actual.getMaxAge();
        if (!Objects.areEqual(actualMaxAge, maxAge)) {
            failWithMessage(assertjErrorMessage, actual, maxAge, actualMaxAge);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's minSeeders is equal to the given one.
     *
     * @param minSeeders the given minSeeders to compare the actual SearchingConfig's minSeeders to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's minSeeders is not equal to the given one.
     */
    public S hasMinSeeders(Integer minSeeders) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting minSeeders of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Integer actualMinSeeders = actual.getMinSeeders();
        if (!Objects.areEqual(actualMinSeeders, minSeeders)) {
            failWithMessage(assertjErrorMessage, actual, minSeeders, actualMinSeeders);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's preselectQuickFilterButtons contains the given String elements.
     *
     * @param preselectQuickFilterButtons the given elements that should be contained in actual SearchingConfig's preselectQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's preselectQuickFilterButtons does not contain all given String elements.
     */
    public S hasPreselectQuickFilterButtons(String... preselectQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (preselectQuickFilterButtons == null) {
            failWithMessage("Expecting preselectQuickFilterButtons parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getPreselectQuickFilterButtons(), preselectQuickFilterButtons);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's preselectQuickFilterButtons contains the given String elements in Collection.
     *
     * @param preselectQuickFilterButtons the given elements that should be contained in actual SearchingConfig's preselectQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's preselectQuickFilterButtons does not contain all given String elements.
     */
    public S hasPreselectQuickFilterButtons(java.util.Collection<? extends String> preselectQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (preselectQuickFilterButtons == null) {
            failWithMessage("Expecting preselectQuickFilterButtons parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getPreselectQuickFilterButtons(), preselectQuickFilterButtons.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's preselectQuickFilterButtons contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param preselectQuickFilterButtons the given elements that should be contained in actual SearchingConfig's preselectQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's preselectQuickFilterButtons does not contain all given String elements.
     */
    public S hasOnlyPreselectQuickFilterButtons(String... preselectQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (preselectQuickFilterButtons == null) {
            failWithMessage("Expecting preselectQuickFilterButtons parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getPreselectQuickFilterButtons(), preselectQuickFilterButtons);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's preselectQuickFilterButtons contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param preselectQuickFilterButtons the given elements that should be contained in actual SearchingConfig's preselectQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's preselectQuickFilterButtons does not contain all given String elements.
     */
    public S hasOnlyPreselectQuickFilterButtons(java.util.Collection<? extends String> preselectQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (preselectQuickFilterButtons == null) {
            failWithMessage("Expecting preselectQuickFilterButtons parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getPreselectQuickFilterButtons(), preselectQuickFilterButtons.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's preselectQuickFilterButtons does not contain the given String elements.
     *
     * @param preselectQuickFilterButtons the given elements that should not be in actual SearchingConfig's preselectQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's preselectQuickFilterButtons contains any given String elements.
     */
    public S doesNotHavePreselectQuickFilterButtons(String... preselectQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (preselectQuickFilterButtons == null) {
            failWithMessage("Expecting preselectQuickFilterButtons parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getPreselectQuickFilterButtons(), preselectQuickFilterButtons);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's preselectQuickFilterButtons does not contain the given String elements in Collection.
     *
     * @param preselectQuickFilterButtons the given elements that should not be in actual SearchingConfig's preselectQuickFilterButtons.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's preselectQuickFilterButtons contains any given String elements.
     */
    public S doesNotHavePreselectQuickFilterButtons(java.util.Collection<? extends String> preselectQuickFilterButtons) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (preselectQuickFilterButtons == null) {
            failWithMessage("Expecting preselectQuickFilterButtons parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getPreselectQuickFilterButtons(), preselectQuickFilterButtons.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no preselectQuickFilterButtons.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's preselectQuickFilterButtons is not empty.
     */
    public S hasNoPreselectQuickFilterButtons() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have preselectQuickFilterButtons but had :\n  <%s>";

        // check
        if (actual.getPreselectQuickFilterButtons().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getPreselectQuickFilterButtons());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig's removeTrailing contains the given String elements.
     *
     * @param removeTrailing the given elements that should be contained in actual SearchingConfig's removeTrailing.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's removeTrailing does not contain all given String elements.
     */
    public S hasRemoveTrailing(String... removeTrailing) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (removeTrailing == null) {
            failWithMessage("Expecting removeTrailing parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getRemoveTrailing(), removeTrailing);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's removeTrailing contains the given String elements in Collection.
     *
     * @param removeTrailing the given elements that should be contained in actual SearchingConfig's removeTrailing.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's removeTrailing does not contain all given String elements.
     */
    public S hasRemoveTrailing(java.util.Collection<? extends String> removeTrailing) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (removeTrailing == null) {
            failWithMessage("Expecting removeTrailing parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getRemoveTrailing(), removeTrailing.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's removeTrailing contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param removeTrailing the given elements that should be contained in actual SearchingConfig's removeTrailing.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's removeTrailing does not contain all given String elements.
     */
    public S hasOnlyRemoveTrailing(String... removeTrailing) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (removeTrailing == null) {
            failWithMessage("Expecting removeTrailing parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getRemoveTrailing(), removeTrailing);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's removeTrailing contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param removeTrailing the given elements that should be contained in actual SearchingConfig's removeTrailing.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's removeTrailing does not contain all given String elements.
     */
    public S hasOnlyRemoveTrailing(java.util.Collection<? extends String> removeTrailing) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (removeTrailing == null) {
            failWithMessage("Expecting removeTrailing parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getRemoveTrailing(), removeTrailing.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's removeTrailing does not contain the given String elements.
     *
     * @param removeTrailing the given elements that should not be in actual SearchingConfig's removeTrailing.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's removeTrailing contains any given String elements.
     */
    public S doesNotHaveRemoveTrailing(String... removeTrailing) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (removeTrailing == null) {
            failWithMessage("Expecting removeTrailing parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getRemoveTrailing(), removeTrailing);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's removeTrailing does not contain the given String elements in Collection.
     *
     * @param removeTrailing the given elements that should not be in actual SearchingConfig's removeTrailing.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's removeTrailing contains any given String elements.
     */
    public S doesNotHaveRemoveTrailing(java.util.Collection<? extends String> removeTrailing) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (removeTrailing == null) {
            failWithMessage("Expecting removeTrailing parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getRemoveTrailing(), removeTrailing.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no removeTrailing.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's removeTrailing is not empty.
     */
    public S hasNoRemoveTrailing() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have removeTrailing but had :\n  <%s>";

        // check
        if (actual.getRemoveTrailing().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getRemoveTrailing());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig is replace umlauts.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not replace umlauts.
     */
    public S isReplaceUmlauts() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isReplaceUmlauts()) {
            failWithMessage("\nExpecting that actual SearchingConfig is replace umlauts but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not replace umlauts.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is replace umlauts.
     */
    public S isNotReplaceUmlauts() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isReplaceUmlauts()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not replace umlauts but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's requiredRegex is equal to the given one.
     *
     * @param requiredRegex the given requiredRegex to compare the actual SearchingConfig's requiredRegex to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's requiredRegex is not equal to the given one.
     */
    public S hasRequiredRegex(java.util.Optional requiredRegex) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting requiredRegex of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualRequiredRegex = actual.getRequiredRegex();
        if (!Objects.areEqual(actualRequiredRegex, requiredRegex)) {
            failWithMessage(assertjErrorMessage, actual, requiredRegex, actualRequiredRegex);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's requiredWords contains the given String elements.
     *
     * @param requiredWords the given elements that should be contained in actual SearchingConfig's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's requiredWords does not contain all given String elements.
     */
    public S hasRequiredWords(String... requiredWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getRequiredWords(), requiredWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's requiredWords contains the given String elements in Collection.
     *
     * @param requiredWords the given elements that should be contained in actual SearchingConfig's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's requiredWords does not contain all given String elements.
     */
    public S hasRequiredWords(java.util.Collection<? extends String> requiredWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getRequiredWords(), requiredWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's requiredWords contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param requiredWords the given elements that should be contained in actual SearchingConfig's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's requiredWords does not contain all given String elements.
     */
    public S hasOnlyRequiredWords(String... requiredWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getRequiredWords(), requiredWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's requiredWords contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param requiredWords the given elements that should be contained in actual SearchingConfig's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's requiredWords does not contain all given String elements.
     */
    public S hasOnlyRequiredWords(java.util.Collection<? extends String> requiredWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getRequiredWords(), requiredWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's requiredWords does not contain the given String elements.
     *
     * @param requiredWords the given elements that should not be in actual SearchingConfig's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's requiredWords contains any given String elements.
     */
    public S doesNotHaveRequiredWords(String... requiredWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getRequiredWords(), requiredWords);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's requiredWords does not contain the given String elements in Collection.
     *
     * @param requiredWords the given elements that should not be in actual SearchingConfig's requiredWords.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's requiredWords contains any given String elements.
     */
    public S doesNotHaveRequiredWords(java.util.Collection<? extends String> requiredWords) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (requiredWords == null) {
            failWithMessage("Expecting requiredWords parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getRequiredWords(), requiredWords.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no requiredWords.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's requiredWords is not empty.
     */
    public S hasNoRequiredWords() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have requiredWords but had :\n  <%s>";

        // check
        if (actual.getRequiredWords().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getRequiredWords());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig is send torznab categories.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not send torznab categories.
     */
    public S isSendTorznabCategories() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isSendTorznabCategories()) {
            failWithMessage("\nExpecting that actual SearchingConfig is send torznab categories but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not send torznab categories.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is send torznab categories.
     */
    public S isNotSendTorznabCategories() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isSendTorznabCategories()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not send torznab categories but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is show quick filter buttons.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not show quick filter buttons.
     */
    public S isShowQuickFilterButtons() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isShowQuickFilterButtons()) {
            failWithMessage("\nExpecting that actual SearchingConfig is show quick filter buttons but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not show quick filter buttons.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is show quick filter buttons.
     */
    public S isNotShowQuickFilterButtons() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isShowQuickFilterButtons()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not show quick filter buttons but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's timeout is equal to the given one.
     *
     * @param timeout the given timeout to compare the actual SearchingConfig's timeout to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's timeout is not equal to the given one.
     */
    public S hasTimeout(Integer timeout) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting timeout of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Integer actualTimeout = actual.getTimeout();
        if (!Objects.areEqual(actualTimeout, timeout)) {
            failWithMessage(assertjErrorMessage, actual, timeout, actualTimeout);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is transform newznab categories.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not transform newznab categories.
     */
    public S isTransformNewznabCategories() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isTransformNewznabCategories()) {
            failWithMessage("\nExpecting that actual SearchingConfig is transform newznab categories but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not transform newznab categories.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is transform newznab categories.
     */
    public S isNotTransformNewznabCategories() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isTransformNewznabCategories()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not transform newznab categories but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is use original categories.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not use original categories.
     */
    public S isUseOriginalCategories() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isUseOriginalCategories()) {
            failWithMessage("\nExpecting that actual SearchingConfig is use original categories but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not use original categories.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is use original categories.
     */
    public S isNotUseOriginalCategories() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isUseOriginalCategories()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not use original categories but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's userAgent is equal to the given one.
     *
     * @param userAgent the given userAgent to compare the actual SearchingConfig's userAgent to.
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig's userAgent is not equal to the given one.
     */
    public S hasUserAgent(java.util.Optional userAgent) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting userAgent of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualUserAgent = actual.getUserAgent();
        if (!Objects.areEqual(actualUserAgent, userAgent)) {
            failWithMessage(assertjErrorMessage, actual, userAgent, actualUserAgent);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's userAgents contains the given String elements.
     *
     * @param userAgents the given elements that should be contained in actual SearchingConfig's userAgents.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's userAgents does not contain all given String elements.
     */
    public S hasUserAgents(String... userAgents) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (userAgents == null) {
            failWithMessage("Expecting userAgents parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getUserAgents(), userAgents);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's userAgents contains the given String elements in Collection.
     *
     * @param userAgents the given elements that should be contained in actual SearchingConfig's userAgents.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's userAgents does not contain all given String elements.
     */
    public S hasUserAgents(java.util.Collection<? extends String> userAgents) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (userAgents == null) {
            failWithMessage("Expecting userAgents parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getUserAgents(), userAgents.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's userAgents contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param userAgents the given elements that should be contained in actual SearchingConfig's userAgents.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's userAgents does not contain all given String elements.
     */
    public S hasOnlyUserAgents(String... userAgents) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (userAgents == null) {
            failWithMessage("Expecting userAgents parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getUserAgents(), userAgents);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's userAgents contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param userAgents the given elements that should be contained in actual SearchingConfig's userAgents.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's userAgents does not contain all given String elements.
     */
    public S hasOnlyUserAgents(java.util.Collection<? extends String> userAgents) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (userAgents == null) {
            failWithMessage("Expecting userAgents parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getUserAgents(), userAgents.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's userAgents does not contain the given String elements.
     *
     * @param userAgents the given elements that should not be in actual SearchingConfig's userAgents.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's userAgents contains any given String elements.
     */
    public S doesNotHaveUserAgents(String... userAgents) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (userAgents == null) {
            failWithMessage("Expecting userAgents parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getUserAgents(), userAgents);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig's userAgents does not contain the given String elements in Collection.
     *
     * @param userAgents the given elements that should not be in actual SearchingConfig's userAgents.
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's userAgents contains any given String elements.
     */
    public S doesNotHaveUserAgents(java.util.Collection<? extends String> userAgents) {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (userAgents == null) {
            failWithMessage("Expecting userAgents parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getUserAgents(), userAgents.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig has no userAgents.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual SearchingConfig's userAgents is not empty.
     */
    public S hasNoUserAgents() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have userAgents but had :\n  <%s>";

        // check
        if (actual.getUserAgents().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getUserAgents());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual SearchingConfig is wrap api errors.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is not wrap api errors.
     */
    public S isWrapApiErrors() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isWrapApiErrors()) {
            failWithMessage("\nExpecting that actual SearchingConfig is wrap api errors but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual SearchingConfig is not wrap api errors.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual SearchingConfig is wrap api errors.
     */
    public S isNotWrapApiErrors() {
        // check that actual SearchingConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isWrapApiErrors()) {
            failWithMessage("\nExpecting that actual SearchingConfig is not wrap api errors but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

}
