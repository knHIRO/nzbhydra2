package org.nzbhydra.config;

import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.internal.Iterables;
import org.assertj.core.util.Objects;

/**
 * Abstract base class for {@link MainConfig} specific assertions - Generated by CustomAssertionGenerator.
 */
@jakarta.annotation.Generated(value = "assertj-assertions-generator")
public abstract class AbstractMainConfigAssert<S extends AbstractMainConfigAssert<S, A>, A extends MainConfig> extends AbstractObjectAssert<S, A> {

    /**
     * Creates a new <code>{@link AbstractMainConfigAssert}</code> to make assertions on actual MainConfig.
     *
     * @param actual the MainConfig we want to make assertions on.
     */
    protected AbstractMainConfigAssert(A actual, Class<S> selfType) {
        super(actual, selfType);
    }

    /**
     * Verifies that the actual MainConfig's apiKey is equal to the given one.
     *
     * @param apiKey the given apiKey to compare the actual MainConfig's apiKey to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's apiKey is not equal to the given one.
     */
    public S hasApiKey(String apiKey) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting apiKey of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualApiKey = actual.getApiKey();
        if (!Objects.areEqual(actualApiKey, apiKey)) {
            failWithMessage(assertjErrorMessage, actual, apiKey, actualApiKey);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is backup before update.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not backup before update.
     */
    public S isBackupBeforeUpdate() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isBackupBeforeUpdate()) {
            failWithMessage("\nExpecting that actual MainConfig is backup before update but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not backup before update.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is backup before update.
     */
    public S isNotBackupBeforeUpdate() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isBackupBeforeUpdate()) {
            failWithMessage("\nExpecting that actual MainConfig is not backup before update but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's backupEveryXDays is equal to the given one.
     *
     * @param backupEveryXDays the given backupEveryXDays to compare the actual MainConfig's backupEveryXDays to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's backupEveryXDays is not equal to the given one.
     */
    public S hasBackupEveryXDays(java.util.Optional backupEveryXDays) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting backupEveryXDays of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualBackupEveryXDays = actual.getBackupEveryXDays();
        if (!Objects.areEqual(actualBackupEveryXDays, backupEveryXDays)) {
            failWithMessage(assertjErrorMessage, actual, backupEveryXDays, actualBackupEveryXDays);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's backupFolder is equal to the given one.
     *
     * @param backupFolder the given backupFolder to compare the actual MainConfig's backupFolder to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's backupFolder is not equal to the given one.
     */
    public S hasBackupFolder(String backupFolder) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting backupFolder of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualBackupFolder = actual.getBackupFolder();
        if (!Objects.areEqual(actualBackupFolder, backupFolder)) {
            failWithMessage(assertjErrorMessage, actual, backupFolder, actualBackupFolder);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's configVersion is equal to the given one.
     *
     * @param configVersion the given configVersion to compare the actual MainConfig's configVersion to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's configVersion is not equal to the given one.
     */
    public S hasConfigVersion(Integer configVersion) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting configVersion of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Integer actualConfigVersion = actual.getConfigVersion();
        if (!Objects.areEqual(actualConfigVersion, configVersion)) {
            failWithMessage(assertjErrorMessage, actual, configVersion, actualConfigVersion);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's databaseCompactTime is equal to the given one.
     *
     * @param databaseCompactTime the given databaseCompactTime to compare the actual MainConfig's databaseCompactTime to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's databaseCompactTime is not equal to the given one.
     */
    public S hasDatabaseCompactTime(int databaseCompactTime) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting databaseCompactTime of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualDatabaseCompactTime = actual.getDatabaseCompactTime();
        if (actualDatabaseCompactTime != databaseCompactTime) {
            failWithMessage(assertjErrorMessage, actual, databaseCompactTime, actualDatabaseCompactTime);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's databaseRetentionTime is equal to the given one.
     *
     * @param databaseRetentionTime the given databaseRetentionTime to compare the actual MainConfig's databaseRetentionTime to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's databaseRetentionTime is not equal to the given one.
     */
    public S hasDatabaseRetentionTime(int databaseRetentionTime) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting databaseRetentionTime of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualDatabaseRetentionTime = actual.getDatabaseRetentionTime();
        if (actualDatabaseRetentionTime != databaseRetentionTime) {
            failWithMessage(assertjErrorMessage, actual, databaseRetentionTime, actualDatabaseRetentionTime);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's databaseWriteDelay is equal to the given one.
     *
     * @param databaseWriteDelay the given databaseWriteDelay to compare the actual MainConfig's databaseWriteDelay to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's databaseWriteDelay is not equal to the given one.
     */
    public S hasDatabaseWriteDelay(int databaseWriteDelay) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting databaseWriteDelay of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualDatabaseWriteDelay = actual.getDatabaseWriteDelay();
        if (actualDatabaseWriteDelay != databaseWriteDelay) {
            failWithMessage(assertjErrorMessage, actual, databaseWriteDelay, actualDatabaseWriteDelay);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's deleteBackupsAfterWeeks is equal to the given one.
     *
     * @param deleteBackupsAfterWeeks the given deleteBackupsAfterWeeks to compare the actual MainConfig's deleteBackupsAfterWeeks to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's deleteBackupsAfterWeeks is not equal to the given one.
     */
    public S hasDeleteBackupsAfterWeeks(java.util.Optional deleteBackupsAfterWeeks) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting deleteBackupsAfterWeeks of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualDeleteBackupsAfterWeeks = actual.getDeleteBackupsAfterWeeks();
        if (!Objects.areEqual(actualDeleteBackupsAfterWeeks, deleteBackupsAfterWeeks)) {
            failWithMessage(assertjErrorMessage, actual, deleteBackupsAfterWeeks, actualDeleteBackupsAfterWeeks);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's dereferer is equal to the given one.
     *
     * @param dereferer the given dereferer to compare the actual MainConfig's dereferer to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's dereferer is not equal to the given one.
     */
    public S hasDereferer(java.util.Optional dereferer) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting dereferer of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualDereferer = actual.getDereferer();
        if (!Objects.areEqual(actualDereferer, dereferer)) {
            failWithMessage(assertjErrorMessage, actual, dereferer, actualDereferer);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is disable ssl locally.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not disable ssl locally.
     */
    public S isDisableSslLocally() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isDisableSslLocally()) {
            failWithMessage("\nExpecting that actual MainConfig is disable ssl locally but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not disable ssl locally.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is disable ssl locally.
     */
    public S isNotDisableSslLocally() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isDisableSslLocally()) {
            failWithMessage("\nExpecting that actual MainConfig is not disable ssl locally but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's host is equal to the given one.
     *
     * @param host the given host to compare the actual MainConfig's host to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's host is not equal to the given one.
     */
    public S hasHost(String host) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting host of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualHost = actual.getHost();
        if (!Objects.areEqual(actualHost, host)) {
            failWithMessage(assertjErrorMessage, actual, host, actualHost);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is instance counter downloaded.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not instance counter downloaded.
     */
    public S isInstanceCounterDownloaded() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isInstanceCounterDownloaded()) {
            failWithMessage("\nExpecting that actual MainConfig is instance counter downloaded but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not instance counter downloaded.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is instance counter downloaded.
     */
    public S isNotInstanceCounterDownloaded() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isInstanceCounterDownloaded()) {
            failWithMessage("\nExpecting that actual MainConfig is not instance counter downloaded but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is keep history.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not keep history.
     */
    public S isKeepHistory() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isKeepHistory()) {
            failWithMessage("\nExpecting that actual MainConfig is keep history but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not keep history.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is keep history.
     */
    public S isNotKeepHistory() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isKeepHistory()) {
            failWithMessage("\nExpecting that actual MainConfig is not keep history but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's keepHistoryForWeeks is equal to the given one.
     *
     * @param keepHistoryForWeeks the given keepHistoryForWeeks to compare the actual MainConfig's keepHistoryForWeeks to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's keepHistoryForWeeks is not equal to the given one.
     */
    public S hasKeepHistoryForWeeks(Integer keepHistoryForWeeks) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting keepHistoryForWeeks of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Integer actualKeepHistoryForWeeks = actual.getKeepHistoryForWeeks();
        if (!Objects.areEqual(actualKeepHistoryForWeeks, keepHistoryForWeeks)) {
            failWithMessage(assertjErrorMessage, actual, keepHistoryForWeeks, actualKeepHistoryForWeeks);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's keepStatsForWeeks is equal to the given one.
     *
     * @param keepStatsForWeeks the given keepStatsForWeeks to compare the actual MainConfig's keepStatsForWeeks to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's keepStatsForWeeks is not equal to the given one.
     */
    public S hasKeepStatsForWeeks(Integer keepStatsForWeeks) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting keepStatsForWeeks of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Integer actualKeepStatsForWeeks = actual.getKeepStatsForWeeks();
        if (!Objects.areEqual(actualKeepStatsForWeeks, keepStatsForWeeks)) {
            failWithMessage(assertjErrorMessage, actual, keepStatsForWeeks, actualKeepStatsForWeeks);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's logging is equal to the given one.
     *
     * @param logging the given logging to compare the actual MainConfig's logging to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's logging is not equal to the given one.
     */
    public S hasLogging(LoggingConfig logging) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting logging of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        LoggingConfig actualLogging = actual.getLogging();
        if (!Objects.areEqual(actualLogging, logging)) {
            failWithMessage(assertjErrorMessage, actual, logging, actualLogging);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's port is equal to the given one.
     *
     * @param port the given port to compare the actual MainConfig's port to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's port is not equal to the given one.
     */
    public S hasPort(int port) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting port of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualPort = actual.getPort();
        if (actualPort != port) {
            failWithMessage(assertjErrorMessage, actual, port, actualPort);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyHost is equal to the given one.
     *
     * @param proxyHost the given proxyHost to compare the actual MainConfig's proxyHost to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's proxyHost is not equal to the given one.
     */
    public S hasProxyHost(String proxyHost) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting proxyHost of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualProxyHost = actual.getProxyHost();
        if (!Objects.areEqual(actualProxyHost, proxyHost)) {
            failWithMessage(assertjErrorMessage, actual, proxyHost, actualProxyHost);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyIgnoreDomains contains the given String elements.
     *
     * @param proxyIgnoreDomains the given elements that should be contained in actual MainConfig's proxyIgnoreDomains.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's proxyIgnoreDomains does not contain all given String elements.
     */
    public S hasProxyIgnoreDomains(String... proxyIgnoreDomains) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (proxyIgnoreDomains == null) {
            failWithMessage("Expecting proxyIgnoreDomains parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getProxyIgnoreDomains(), proxyIgnoreDomains);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyIgnoreDomains contains the given String elements in Collection.
     *
     * @param proxyIgnoreDomains the given elements that should be contained in actual MainConfig's proxyIgnoreDomains.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's proxyIgnoreDomains does not contain all given String elements.
     */
    public S hasProxyIgnoreDomains(java.util.Collection<? extends String> proxyIgnoreDomains) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (proxyIgnoreDomains == null) {
            failWithMessage("Expecting proxyIgnoreDomains parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getProxyIgnoreDomains(), proxyIgnoreDomains.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyIgnoreDomains contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param proxyIgnoreDomains the given elements that should be contained in actual MainConfig's proxyIgnoreDomains.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's proxyIgnoreDomains does not contain all given String elements.
     */
    public S hasOnlyProxyIgnoreDomains(String... proxyIgnoreDomains) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (proxyIgnoreDomains == null) {
            failWithMessage("Expecting proxyIgnoreDomains parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getProxyIgnoreDomains(), proxyIgnoreDomains);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyIgnoreDomains contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param proxyIgnoreDomains the given elements that should be contained in actual MainConfig's proxyIgnoreDomains.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's proxyIgnoreDomains does not contain all given String elements.
     */
    public S hasOnlyProxyIgnoreDomains(java.util.Collection<? extends String> proxyIgnoreDomains) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (proxyIgnoreDomains == null) {
            failWithMessage("Expecting proxyIgnoreDomains parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getProxyIgnoreDomains(), proxyIgnoreDomains.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyIgnoreDomains does not contain the given String elements.
     *
     * @param proxyIgnoreDomains the given elements that should not be in actual MainConfig's proxyIgnoreDomains.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's proxyIgnoreDomains contains any given String elements.
     */
    public S doesNotHaveProxyIgnoreDomains(String... proxyIgnoreDomains) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (proxyIgnoreDomains == null) {
            failWithMessage("Expecting proxyIgnoreDomains parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getProxyIgnoreDomains(), proxyIgnoreDomains);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyIgnoreDomains does not contain the given String elements in Collection.
     *
     * @param proxyIgnoreDomains the given elements that should not be in actual MainConfig's proxyIgnoreDomains.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's proxyIgnoreDomains contains any given String elements.
     */
    public S doesNotHaveProxyIgnoreDomains(java.util.Collection<? extends String> proxyIgnoreDomains) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (proxyIgnoreDomains == null) {
            failWithMessage("Expecting proxyIgnoreDomains parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getProxyIgnoreDomains(), proxyIgnoreDomains.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig has no proxyIgnoreDomains.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's proxyIgnoreDomains is not empty.
     */
    public S hasNoProxyIgnoreDomains() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have proxyIgnoreDomains but had :\n  <%s>";

        // check
        if (actual.getProxyIgnoreDomains().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getProxyIgnoreDomains());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual MainConfig is proxy ignore local.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not proxy ignore local.
     */
    public S isProxyIgnoreLocal() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isProxyIgnoreLocal()) {
            failWithMessage("\nExpecting that actual MainConfig is proxy ignore local but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not proxy ignore local.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is proxy ignore local.
     */
    public S isNotProxyIgnoreLocal() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isProxyIgnoreLocal()) {
            failWithMessage("\nExpecting that actual MainConfig is not proxy ignore local but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyPassword is equal to the given one.
     *
     * @param proxyPassword the given proxyPassword to compare the actual MainConfig's proxyPassword to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's proxyPassword is not equal to the given one.
     */
    public S hasProxyPassword(String proxyPassword) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting proxyPassword of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualProxyPassword = actual.getProxyPassword();
        if (!Objects.areEqual(actualProxyPassword, proxyPassword)) {
            failWithMessage(assertjErrorMessage, actual, proxyPassword, actualProxyPassword);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyPort is equal to the given one.
     *
     * @param proxyPort the given proxyPort to compare the actual MainConfig's proxyPort to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's proxyPort is not equal to the given one.
     */
    public S hasProxyPort(int proxyPort) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting proxyPort of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualProxyPort = actual.getProxyPort();
        if (actualProxyPort != proxyPort) {
            failWithMessage(assertjErrorMessage, actual, proxyPort, actualProxyPort);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyType is equal to the given one.
     *
     * @param proxyType the given proxyType to compare the actual MainConfig's proxyType to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's proxyType is not equal to the given one.
     */
    public S hasProxyType(ProxyType proxyType) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting proxyType of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        ProxyType actualProxyType = actual.getProxyType();
        if (!Objects.areEqual(actualProxyType, proxyType)) {
            failWithMessage(assertjErrorMessage, actual, proxyType, actualProxyType);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's proxyUsername is equal to the given one.
     *
     * @param proxyUsername the given proxyUsername to compare the actual MainConfig's proxyUsername to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's proxyUsername is not equal to the given one.
     */
    public S hasProxyUsername(String proxyUsername) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting proxyUsername of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualProxyUsername = actual.getProxyUsername();
        if (!Objects.areEqual(actualProxyUsername, proxyUsername)) {
            failWithMessage(assertjErrorMessage, actual, proxyUsername, actualProxyUsername);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's repositoryBase is equal to the given one.
     *
     * @param repositoryBase the given repositoryBase to compare the actual MainConfig's repositoryBase to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's repositoryBase is not equal to the given one.
     */
    public S hasRepositoryBase(String repositoryBase) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting repositoryBase of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualRepositoryBase = actual.getRepositoryBase();
        if (!Objects.areEqual(actualRepositoryBase, repositoryBase)) {
            failWithMessage(assertjErrorMessage, actual, repositoryBase, actualRepositoryBase);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is show news.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not show news.
     */
    public S isShowNews() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isShowNews()) {
            failWithMessage("\nExpecting that actual MainConfig is show news but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not show news.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is show news.
     */
    public S isNotShowNews() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isShowNews()) {
            failWithMessage("\nExpecting that actual MainConfig is not show news but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is show update banner on updated externally.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not show update banner on updated externally.
     */
    public S isShowUpdateBannerOnUpdatedExternally() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isShowUpdateBannerOnUpdatedExternally()) {
            failWithMessage("\nExpecting that actual MainConfig is show update banner on updated externally but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not show update banner on updated externally.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is show update banner on updated externally.
     */
    public S isNotShowUpdateBannerOnUpdatedExternally() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isShowUpdateBannerOnUpdatedExternally()) {
            failWithMessage("\nExpecting that actual MainConfig is not show update banner on updated externally but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is show whats new banner.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not show whats new banner.
     */
    public S isShowWhatsNewBanner() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isShowWhatsNewBanner()) {
            failWithMessage("\nExpecting that actual MainConfig is show whats new banner but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not show whats new banner.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is show whats new banner.
     */
    public S isNotShowWhatsNewBanner() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isShowWhatsNewBanner()) {
            failWithMessage("\nExpecting that actual MainConfig is not show whats new banner but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is shutdown for restart.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not shutdown for restart.
     */
    public S isShutdownForRestart() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isShutdownForRestart()) {
            failWithMessage("\nExpecting that actual MainConfig is shutdown for restart but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not shutdown for restart.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is shutdown for restart.
     */
    public S isNotShutdownForRestart() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isShutdownForRestart()) {
            failWithMessage("\nExpecting that actual MainConfig is not shutdown for restart but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sniDisabledFor contains the given String elements.
     *
     * @param sniDisabledFor the given elements that should be contained in actual MainConfig's sniDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's sniDisabledFor does not contain all given String elements.
     */
    public S hasSniDisabledFor(String... sniDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (sniDisabledFor == null) {
            failWithMessage("Expecting sniDisabledFor parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSniDisabledFor(), sniDisabledFor);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sniDisabledFor contains the given String elements in Collection.
     *
     * @param sniDisabledFor the given elements that should be contained in actual MainConfig's sniDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's sniDisabledFor does not contain all given String elements.
     */
    public S hasSniDisabledFor(java.util.Collection<? extends String> sniDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (sniDisabledFor == null) {
            failWithMessage("Expecting sniDisabledFor parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSniDisabledFor(), sniDisabledFor.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sniDisabledFor contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param sniDisabledFor the given elements that should be contained in actual MainConfig's sniDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's sniDisabledFor does not contain all given String elements.
     */
    public S hasOnlySniDisabledFor(String... sniDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (sniDisabledFor == null) {
            failWithMessage("Expecting sniDisabledFor parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSniDisabledFor(), sniDisabledFor);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sniDisabledFor contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param sniDisabledFor the given elements that should be contained in actual MainConfig's sniDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's sniDisabledFor does not contain all given String elements.
     */
    public S hasOnlySniDisabledFor(java.util.Collection<? extends String> sniDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (sniDisabledFor == null) {
            failWithMessage("Expecting sniDisabledFor parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSniDisabledFor(), sniDisabledFor.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sniDisabledFor does not contain the given String elements.
     *
     * @param sniDisabledFor the given elements that should not be in actual MainConfig's sniDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's sniDisabledFor contains any given String elements.
     */
    public S doesNotHaveSniDisabledFor(String... sniDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (sniDisabledFor == null) {
            failWithMessage("Expecting sniDisabledFor parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSniDisabledFor(), sniDisabledFor);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sniDisabledFor does not contain the given String elements in Collection.
     *
     * @param sniDisabledFor the given elements that should not be in actual MainConfig's sniDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's sniDisabledFor contains any given String elements.
     */
    public S doesNotHaveSniDisabledFor(java.util.Collection<? extends String> sniDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (sniDisabledFor == null) {
            failWithMessage("Expecting sniDisabledFor parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSniDisabledFor(), sniDisabledFor.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig has no sniDisabledFor.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's sniDisabledFor is not empty.
     */
    public S hasNoSniDisabledFor() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have sniDisabledFor but had :\n  <%s>";

        // check
        if (actual.getSniDisabledFor().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getSniDisabledFor());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual MainConfig is ssl.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not ssl.
     */
    public S isSsl() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isSsl()) {
            failWithMessage("\nExpecting that actual MainConfig is ssl but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not ssl.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is ssl.
     */
    public S isNotSsl() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isSsl()) {
            failWithMessage("\nExpecting that actual MainConfig is not ssl but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sslKeyStore is equal to the given one.
     *
     * @param sslKeyStore the given sslKeyStore to compare the actual MainConfig's sslKeyStore to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's sslKeyStore is not equal to the given one.
     */
    public S hasSslKeyStore(String sslKeyStore) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting sslKeyStore of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualSslKeyStore = actual.getSslKeyStore();
        if (!Objects.areEqual(actualSslKeyStore, sslKeyStore)) {
            failWithMessage(assertjErrorMessage, actual, sslKeyStore, actualSslKeyStore);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's sslKeyStorePassword is equal to the given one.
     *
     * @param sslKeyStorePassword the given sslKeyStorePassword to compare the actual MainConfig's sslKeyStorePassword to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's sslKeyStorePassword is not equal to the given one.
     */
    public S hasSslKeyStorePassword(String sslKeyStorePassword) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting sslKeyStorePassword of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualSslKeyStorePassword = actual.getSslKeyStorePassword();
        if (!Objects.areEqual(actualSslKeyStorePassword, sslKeyStorePassword)) {
            failWithMessage(assertjErrorMessage, actual, sslKeyStorePassword, actualSslKeyStorePassword);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is startup browser.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not startup browser.
     */
    public S isStartupBrowser() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isStartupBrowser()) {
            failWithMessage("\nExpecting that actual MainConfig is startup browser but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not startup browser.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is startup browser.
     */
    public S isNotStartupBrowser() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isStartupBrowser()) {
            failWithMessage("\nExpecting that actual MainConfig is not startup browser but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's theme is equal to the given one.
     *
     * @param theme the given theme to compare the actual MainConfig's theme to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's theme is not equal to the given one.
     */
    public S hasTheme(String theme) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting theme of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualTheme = actual.getTheme();
        if (!Objects.areEqual(actualTheme, theme)) {
            failWithMessage(assertjErrorMessage, actual, theme, actualTheme);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is update automatically.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not update automatically.
     */
    public S isUpdateAutomatically() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isUpdateAutomatically()) {
            failWithMessage("\nExpecting that actual MainConfig is update automatically but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not update automatically.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is update automatically.
     */
    public S isNotUpdateAutomatically() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isUpdateAutomatically()) {
            failWithMessage("\nExpecting that actual MainConfig is not update automatically but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is update check enabled.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not update check enabled.
     */
    public S isUpdateCheckEnabled() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isUpdateCheckEnabled()) {
            failWithMessage("\nExpecting that actual MainConfig is update check enabled but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not update check enabled.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is update check enabled.
     */
    public S isNotUpdateCheckEnabled() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isUpdateCheckEnabled()) {
            failWithMessage("\nExpecting that actual MainConfig is not update check enabled but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is update to prereleases.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not update to prereleases.
     */
    public S isUpdateToPrereleases() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isUpdateToPrereleases()) {
            failWithMessage("\nExpecting that actual MainConfig is update to prereleases but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not update to prereleases.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is update to prereleases.
     */
    public S isNotUpdateToPrereleases() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isUpdateToPrereleases()) {
            failWithMessage("\nExpecting that actual MainConfig is not update to prereleases but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's urlBase is equal to the given one.
     *
     * @param urlBase the given urlBase to compare the actual MainConfig's urlBase to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's urlBase is not equal to the given one.
     */
    public S hasUrlBase(java.util.Optional urlBase) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting urlBase of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualUrlBase = actual.getUrlBase();
        if (!Objects.areEqual(actualUrlBase, urlBase)) {
            failWithMessage(assertjErrorMessage, actual, urlBase, actualUrlBase);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is use csrf.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not use csrf.
     */
    public S isUseCsrf() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isUseCsrf()) {
            failWithMessage("\nExpecting that actual MainConfig is use csrf but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not use csrf.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is use csrf.
     */
    public S isNotUseCsrf() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isUseCsrf()) {
            failWithMessage("\nExpecting that actual MainConfig is not use csrf but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is verify ssl.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not verify ssl.
     */
    public S isVerifySsl() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isVerifySsl()) {
            failWithMessage("\nExpecting that actual MainConfig is verify ssl but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not verify ssl.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is verify ssl.
     */
    public S isNotVerifySsl() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isVerifySsl()) {
            failWithMessage("\nExpecting that actual MainConfig is not verify ssl but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's verifySslDisabledFor contains the given String elements.
     *
     * @param verifySslDisabledFor the given elements that should be contained in actual MainConfig's verifySslDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's verifySslDisabledFor does not contain all given String elements.
     */
    public S hasVerifySslDisabledFor(String... verifySslDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (verifySslDisabledFor == null) {
            failWithMessage("Expecting verifySslDisabledFor parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getVerifySslDisabledFor(), verifySslDisabledFor);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's verifySslDisabledFor contains the given String elements in Collection.
     *
     * @param verifySslDisabledFor the given elements that should be contained in actual MainConfig's verifySslDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's verifySslDisabledFor does not contain all given String elements.
     */
    public S hasVerifySslDisabledFor(java.util.Collection<? extends String> verifySslDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (verifySslDisabledFor == null) {
            failWithMessage("Expecting verifySslDisabledFor parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getVerifySslDisabledFor(), verifySslDisabledFor.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's verifySslDisabledFor contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param verifySslDisabledFor the given elements that should be contained in actual MainConfig's verifySslDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's verifySslDisabledFor does not contain all given String elements.
     */
    public S hasOnlyVerifySslDisabledFor(String... verifySslDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (verifySslDisabledFor == null) {
            failWithMessage("Expecting verifySslDisabledFor parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getVerifySslDisabledFor(), verifySslDisabledFor);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's verifySslDisabledFor contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param verifySslDisabledFor the given elements that should be contained in actual MainConfig's verifySslDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's verifySslDisabledFor does not contain all given String elements.
     */
    public S hasOnlyVerifySslDisabledFor(java.util.Collection<? extends String> verifySslDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (verifySslDisabledFor == null) {
            failWithMessage("Expecting verifySslDisabledFor parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getVerifySslDisabledFor(), verifySslDisabledFor.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's verifySslDisabledFor does not contain the given String elements.
     *
     * @param verifySslDisabledFor the given elements that should not be in actual MainConfig's verifySslDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's verifySslDisabledFor contains any given String elements.
     */
    public S doesNotHaveVerifySslDisabledFor(String... verifySslDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (verifySslDisabledFor == null) {
            failWithMessage("Expecting verifySslDisabledFor parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getVerifySslDisabledFor(), verifySslDisabledFor);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's verifySslDisabledFor does not contain the given String elements in Collection.
     *
     * @param verifySslDisabledFor the given elements that should not be in actual MainConfig's verifySslDisabledFor.
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's verifySslDisabledFor contains any given String elements.
     */
    public S doesNotHaveVerifySslDisabledFor(java.util.Collection<? extends String> verifySslDisabledFor) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (verifySslDisabledFor == null) {
            failWithMessage("Expecting verifySslDisabledFor parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getVerifySslDisabledFor(), verifySslDisabledFor.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig has no verifySslDisabledFor.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual MainConfig's verifySslDisabledFor is not empty.
     */
    public S hasNoVerifySslDisabledFor() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have verifySslDisabledFor but had :\n  <%s>";

        // check
        if (actual.getVerifySslDisabledFor().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getVerifySslDisabledFor());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual MainConfig is welcome shown.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is not welcome shown.
     */
    public S isWelcomeShown() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isWelcomeShown()) {
            failWithMessage("\nExpecting that actual MainConfig is welcome shown but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig is not welcome shown.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig is welcome shown.
     */
    public S isNotWelcomeShown() {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isWelcomeShown()) {
            failWithMessage("\nExpecting that actual MainConfig is not welcome shown but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual MainConfig's xmx is equal to the given one.
     *
     * @param xmx the given xmx to compare the actual MainConfig's xmx to.
     * @return this assertion object.
     * @throws AssertionError - if the actual MainConfig's xmx is not equal to the given one.
     */
    public S hasXmx(int xmx) {
        // check that actual MainConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting xmx of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualXmx = actual.getXmx();
        if (actualXmx != xmx) {
            failWithMessage(assertjErrorMessage, actual, xmx, actualXmx);
        }

        // return the current assertion for method chaining
        return myself;
    }

}
