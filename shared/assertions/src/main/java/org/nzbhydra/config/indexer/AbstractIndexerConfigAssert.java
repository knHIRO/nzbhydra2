package org.nzbhydra.config.indexer;

import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.internal.Iterables;
import org.assertj.core.util.Objects;

/**
 * Abstract base class for {@link IndexerConfig} specific assertions - Generated by CustomAssertionGenerator.
 */
@jakarta.annotation.Generated(value = "assertj-assertions-generator")
public abstract class AbstractIndexerConfigAssert<S extends AbstractIndexerConfigAssert<S, A>, A extends IndexerConfig> extends AbstractObjectAssert<S, A> {

    /**
     * Creates a new <code>{@link AbstractIndexerConfigAssert}</code> to make assertions on actual IndexerConfig.
     *
     * @param actual the IndexerConfig we want to make assertions on.
     */
    protected AbstractIndexerConfigAssert(A actual, Class<S> selfType) {
        super(actual, selfType);
    }

    /**
     * Verifies that the actual IndexerConfig is all caps checked.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is not all caps checked.
     */
    public S isAllCapsChecked() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isAllCapsChecked()) {
            failWithMessage("\nExpecting that actual IndexerConfig is all caps checked but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is not all caps checked.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is all caps checked.
     */
    public S isNotAllCapsChecked() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isAllCapsChecked()) {
            failWithMessage("\nExpecting that actual IndexerConfig is not all caps checked but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's apiKey is equal to the given one.
     *
     * @param apiKey the given apiKey to compare the actual IndexerConfig's apiKey to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's apiKey is not equal to the given one.
     */
    public S hasApiKey(String apiKey) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting apiKey of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualApiKey = actual.getApiKey();
        if (!Objects.areEqual(actualApiKey, apiKey)) {
            failWithMessage(assertjErrorMessage, actual, apiKey, actualApiKey);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's apiPath is equal to the given one.
     *
     * @param apiPath the given apiPath to compare the actual IndexerConfig's apiPath to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's apiPath is not equal to the given one.
     */
    public S hasApiPath(java.util.Optional apiPath) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting apiPath of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualApiPath = actual.getApiPath();
        if (!Objects.areEqual(actualApiPath, apiPath)) {
            failWithMessage(assertjErrorMessage, actual, apiPath, actualApiPath);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's backend is equal to the given one.
     *
     * @param backend the given backend to compare the actual IndexerConfig's backend to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's backend is not equal to the given one.
     */
    public S hasBackend(BackendType backend) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting backend of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        BackendType actualBackend = actual.getBackend();
        if (!Objects.areEqual(actualBackend, backend)) {
            failWithMessage(assertjErrorMessage, actual, backend, actualBackend);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's categoryMapping is equal to the given one.
     *
     * @param categoryMapping the given categoryMapping to compare the actual IndexerConfig's categoryMapping to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's categoryMapping is not equal to the given one.
     */
    public S hasCategoryMapping(IndexerCategoryConfig categoryMapping) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting categoryMapping of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        IndexerCategoryConfig actualCategoryMapping = actual.getCategoryMapping();
        if (!Objects.areEqual(actualCategoryMapping, categoryMapping)) {
            failWithMessage(assertjErrorMessage, actual, categoryMapping, actualCategoryMapping);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's color is equal to the given one.
     *
     * @param color the given color to compare the actual IndexerConfig's color to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's color is not equal to the given one.
     */
    public S hasColor(String color) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting color of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualColor = actual.getColor();
        if (!Objects.areEqual(actualColor, color)) {
            failWithMessage(assertjErrorMessage, actual, color, actualColor);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is config complete.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is not config complete.
     */
    public S isConfigComplete() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isConfigComplete()) {
            failWithMessage("\nExpecting that actual IndexerConfig is config complete but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is not config complete.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is config complete.
     */
    public S isNotConfigComplete() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isConfigComplete()) {
            failWithMessage("\nExpecting that actual IndexerConfig is not config complete but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's customParameters contains the given String elements.
     *
     * @param customParameters the given elements that should be contained in actual IndexerConfig's customParameters.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's customParameters does not contain all given String elements.
     */
    public S hasCustomParameters(String... customParameters) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (customParameters == null) {
            failWithMessage("Expecting customParameters parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getCustomParameters(), customParameters);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's customParameters contains the given String elements in Collection.
     *
     * @param customParameters the given elements that should be contained in actual IndexerConfig's customParameters.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's customParameters does not contain all given String elements.
     */
    public S hasCustomParameters(java.util.Collection<? extends String> customParameters) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (customParameters == null) {
            failWithMessage("Expecting customParameters parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getCustomParameters(), customParameters.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's customParameters contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param customParameters the given elements that should be contained in actual IndexerConfig's customParameters.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's customParameters does not contain all given String elements.
     */
    public S hasOnlyCustomParameters(String... customParameters) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (customParameters == null) {
            failWithMessage("Expecting customParameters parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getCustomParameters(), customParameters);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's customParameters contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param customParameters the given elements that should be contained in actual IndexerConfig's customParameters.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's customParameters does not contain all given String elements.
     */
    public S hasOnlyCustomParameters(java.util.Collection<? extends String> customParameters) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (customParameters == null) {
            failWithMessage("Expecting customParameters parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getCustomParameters(), customParameters.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's customParameters does not contain the given String elements.
     *
     * @param customParameters the given elements that should not be in actual IndexerConfig's customParameters.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's customParameters contains any given String elements.
     */
    public S doesNotHaveCustomParameters(String... customParameters) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (customParameters == null) {
            failWithMessage("Expecting customParameters parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getCustomParameters(), customParameters);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's customParameters does not contain the given String elements in Collection.
     *
     * @param customParameters the given elements that should not be in actual IndexerConfig's customParameters.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's customParameters contains any given String elements.
     */
    public S doesNotHaveCustomParameters(java.util.Collection<? extends String> customParameters) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (customParameters == null) {
            failWithMessage("Expecting customParameters parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getCustomParameters(), customParameters.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig has no customParameters.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's customParameters is not empty.
     */
    public S hasNoCustomParameters() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have customParameters but had :\n  <%s>";

        // check
        if (actual.getCustomParameters().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getCustomParameters());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual IndexerConfig's disabledAt is equal to the given one.
     *
     * @param disabledAt the given disabledAt to compare the actual IndexerConfig's disabledAt to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's disabledAt is not equal to the given one.
     */
    public S hasDisabledAt(java.time.Instant disabledAt) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting disabledAt of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.time.Instant actualDisabledAt = actual.getDisabledAt();
        if (!Objects.areEqual(actualDisabledAt, disabledAt)) {
            failWithMessage(assertjErrorMessage, actual, disabledAt, actualDisabledAt);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's disabledLevel is equal to the given one.
     *
     * @param disabledLevel the given disabledLevel to compare the actual IndexerConfig's disabledLevel to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's disabledLevel is not equal to the given one.
     */
    public S hasDisabledLevel(int disabledLevel) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting disabledLevel of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualDisabledLevel = actual.getDisabledLevel();
        if (actualDisabledLevel != disabledLevel) {
            failWithMessage(assertjErrorMessage, actual, disabledLevel, actualDisabledLevel);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's disabledUntil is equal to the given one.
     *
     * @param disabledUntil the given disabledUntil to compare the actual IndexerConfig's disabledUntil to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's disabledUntil is not equal to the given one.
     */
    public S hasDisabledUntil(Long disabledUntil) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting disabledUntil of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Long actualDisabledUntil = actual.getDisabledUntil();
        if (!Objects.areEqual(actualDisabledUntil, disabledUntil)) {
            failWithMessage(assertjErrorMessage, actual, disabledUntil, actualDisabledUntil);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's downloadLimit is equal to the given one.
     *
     * @param downloadLimit the given downloadLimit to compare the actual IndexerConfig's downloadLimit to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's downloadLimit is not equal to the given one.
     */
    public S hasDownloadLimit(java.util.Optional downloadLimit) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting downloadLimit of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualDownloadLimit = actual.getDownloadLimit();
        if (!Objects.areEqual(actualDownloadLimit, downloadLimit)) {
            failWithMessage(assertjErrorMessage, actual, downloadLimit, actualDownloadLimit);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is eligible for internal search.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is not eligible for internal search.
     */
    public S isEligibleForInternalSearch() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isEligibleForInternalSearch()) {
            failWithMessage("\nExpecting that actual IndexerConfig is eligible for internal search but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is not eligible for internal search.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is eligible for internal search.
     */
    public S isNotEligibleForInternalSearch() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isEligibleForInternalSearch()) {
            failWithMessage("\nExpecting that actual IndexerConfig is not eligible for internal search but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's enabledCategories contains the given String elements.
     *
     * @param enabledCategories the given elements that should be contained in actual IndexerConfig's enabledCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's enabledCategories does not contain all given String elements.
     */
    public S hasEnabledCategories(String... enabledCategories) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (enabledCategories == null) {
            failWithMessage("Expecting enabledCategories parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getEnabledCategories(), enabledCategories);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's enabledCategories contains the given String elements in Collection.
     *
     * @param enabledCategories the given elements that should be contained in actual IndexerConfig's enabledCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's enabledCategories does not contain all given String elements.
     */
    public S hasEnabledCategories(java.util.Collection<? extends String> enabledCategories) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (enabledCategories == null) {
            failWithMessage("Expecting enabledCategories parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getEnabledCategories(), enabledCategories.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's enabledCategories contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param enabledCategories the given elements that should be contained in actual IndexerConfig's enabledCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's enabledCategories does not contain all given String elements.
     */
    public S hasOnlyEnabledCategories(String... enabledCategories) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (enabledCategories == null) {
            failWithMessage("Expecting enabledCategories parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getEnabledCategories(), enabledCategories);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's enabledCategories contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param enabledCategories the given elements that should be contained in actual IndexerConfig's enabledCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's enabledCategories does not contain all given String elements.
     */
    public S hasOnlyEnabledCategories(java.util.Collection<? extends String> enabledCategories) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (enabledCategories == null) {
            failWithMessage("Expecting enabledCategories parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getEnabledCategories(), enabledCategories.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's enabledCategories does not contain the given String elements.
     *
     * @param enabledCategories the given elements that should not be in actual IndexerConfig's enabledCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's enabledCategories contains any given String elements.
     */
    public S doesNotHaveEnabledCategories(String... enabledCategories) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (enabledCategories == null) {
            failWithMessage("Expecting enabledCategories parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getEnabledCategories(), enabledCategories);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's enabledCategories does not contain the given String elements in Collection.
     *
     * @param enabledCategories the given elements that should not be in actual IndexerConfig's enabledCategories.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's enabledCategories contains any given String elements.
     */
    public S doesNotHaveEnabledCategories(java.util.Collection<? extends String> enabledCategories) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (enabledCategories == null) {
            failWithMessage("Expecting enabledCategories parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getEnabledCategories(), enabledCategories.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig has no enabledCategories.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's enabledCategories is not empty.
     */
    public S hasNoEnabledCategories() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have enabledCategories but had :\n  <%s>";

        // check
        if (actual.getEnabledCategories().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getEnabledCategories());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual IndexerConfig's enabledForSearchSource is equal to the given one.
     *
     * @param enabledForSearchSource the given enabledForSearchSource to compare the actual IndexerConfig's enabledForSearchSource to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's enabledForSearchSource is not equal to the given one.
     */
    public S hasEnabledForSearchSource(org.nzbhydra.config.SearchSourceRestriction enabledForSearchSource) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting enabledForSearchSource of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        org.nzbhydra.config.SearchSourceRestriction actualEnabledForSearchSource = actual.getEnabledForSearchSource();
        if (!Objects.areEqual(actualEnabledForSearchSource, enabledForSearchSource)) {
            failWithMessage(assertjErrorMessage, actual, enabledForSearchSource, actualEnabledForSearchSource);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's generalMinSize is equal to the given one.
     *
     * @param generalMinSize the given generalMinSize to compare the actual IndexerConfig's generalMinSize to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's generalMinSize is not equal to the given one.
     */
    public S hasGeneralMinSize(java.util.Optional generalMinSize) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting generalMinSize of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualGeneralMinSize = actual.getGeneralMinSize();
        if (!Objects.areEqual(actualGeneralMinSize, generalMinSize)) {
            failWithMessage(assertjErrorMessage, actual, generalMinSize, actualGeneralMinSize);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's hitLimit is equal to the given one.
     *
     * @param hitLimit the given hitLimit to compare the actual IndexerConfig's hitLimit to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's hitLimit is not equal to the given one.
     */
    public S hasHitLimit(java.util.Optional hitLimit) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting hitLimit of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualHitLimit = actual.getHitLimit();
        if (!Objects.areEqual(actualHitLimit, hitLimit)) {
            failWithMessage(assertjErrorMessage, actual, hitLimit, actualHitLimit);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's hitLimitResetTime is equal to the given one.
     *
     * @param hitLimitResetTime the given hitLimitResetTime to compare the actual IndexerConfig's hitLimitResetTime to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's hitLimitResetTime is not equal to the given one.
     */
    public S hasHitLimitResetTime(java.util.Optional hitLimitResetTime) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting hitLimitResetTime of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualHitLimitResetTime = actual.getHitLimitResetTime();
        if (!Objects.areEqual(actualHitLimitResetTime, hitLimitResetTime)) {
            failWithMessage(assertjErrorMessage, actual, hitLimitResetTime, actualHitLimitResetTime);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's host is equal to the given one.
     *
     * @param host the given host to compare the actual IndexerConfig's host to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's host is not equal to the given one.
     */
    public S hasHost(String host) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting host of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualHost = actual.getHost();
        if (!Objects.areEqual(actualHost, host)) {
            failWithMessage(assertjErrorMessage, actual, host, actualHost);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's lastError is equal to the given one.
     *
     * @param lastError the given lastError to compare the actual IndexerConfig's lastError to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's lastError is not equal to the given one.
     */
    public S hasLastError(String lastError) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting lastError of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualLastError = actual.getLastError();
        if (!Objects.areEqual(actualLastError, lastError)) {
            failWithMessage(assertjErrorMessage, actual, lastError, actualLastError);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's loadLimitOnRandom is equal to the given one.
     *
     * @param loadLimitOnRandom the given loadLimitOnRandom to compare the actual IndexerConfig's loadLimitOnRandom to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's loadLimitOnRandom is not equal to the given one.
     */
    public S hasLoadLimitOnRandom(java.util.Optional loadLimitOnRandom) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting loadLimitOnRandom of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualLoadLimitOnRandom = actual.getLoadLimitOnRandom();
        if (!Objects.areEqual(actualLoadLimitOnRandom, loadLimitOnRandom)) {
            failWithMessage(assertjErrorMessage, actual, loadLimitOnRandom, actualLoadLimitOnRandom);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's minSeeders is equal to the given one.
     *
     * @param minSeeders the given minSeeders to compare the actual IndexerConfig's minSeeders to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's minSeeders is not equal to the given one.
     */
    public S hasMinSeeders(Integer minSeeders) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting minSeeders of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        Integer actualMinSeeders = actual.getMinSeeders();
        if (!Objects.areEqual(actualMinSeeders, minSeeders)) {
            failWithMessage(assertjErrorMessage, actual, minSeeders, actualMinSeeders);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's name is equal to the given one.
     *
     * @param name the given name to compare the actual IndexerConfig's name to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's name is not equal to the given one.
     */
    public S hasName(String name) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting name of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualName = actual.getName();
        if (!Objects.areEqual(actualName, name)) {
            failWithMessage(assertjErrorMessage, actual, name, actualName);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's password is equal to the given one.
     *
     * @param password the given password to compare the actual IndexerConfig's password to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's password is not equal to the given one.
     */
    public S hasPassword(java.util.Optional password) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting password of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualPassword = actual.getPassword();
        if (!Objects.areEqual(actualPassword, password)) {
            failWithMessage(assertjErrorMessage, actual, password, actualPassword);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is preselect.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is not preselect.
     */
    public S isPreselect() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isPreselect()) {
            failWithMessage("\nExpecting that actual IndexerConfig is preselect but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is not preselect.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is preselect.
     */
    public S isNotPreselect() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isPreselect()) {
            failWithMessage("\nExpecting that actual IndexerConfig is not preselect but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's schedule contains the given String elements.
     *
     * @param schedule the given elements that should be contained in actual IndexerConfig's schedule.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's schedule does not contain all given String elements.
     */
    public S hasSchedule(String... schedule) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (schedule == null) {
            failWithMessage("Expecting schedule parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSchedule(), schedule);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's schedule contains the given String elements in Collection.
     *
     * @param schedule the given elements that should be contained in actual IndexerConfig's schedule.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's schedule does not contain all given String elements.
     */
    public S hasSchedule(java.util.Collection<? extends String> schedule) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (schedule == null) {
            failWithMessage("Expecting schedule parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSchedule(), schedule.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's schedule contains <b>only</b> the given String elements and nothing else in whatever order.
     *
     * @param schedule the given elements that should be contained in actual IndexerConfig's schedule.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's schedule does not contain all given String elements.
     */
    public S hasOnlySchedule(String... schedule) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (schedule == null) {
            failWithMessage("Expecting schedule parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSchedule(), schedule);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's schedule contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
     *
     * @param schedule the given elements that should be contained in actual IndexerConfig's schedule.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's schedule does not contain all given String elements.
     */
    public S hasOnlySchedule(java.util.Collection<? extends String> schedule) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (schedule == null) {
            failWithMessage("Expecting schedule parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSchedule(), schedule.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's schedule does not contain the given String elements.
     *
     * @param schedule the given elements that should not be in actual IndexerConfig's schedule.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's schedule contains any given String elements.
     */
    public S doesNotHaveSchedule(String... schedule) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String varargs is not null.
        if (schedule == null) {
            failWithMessage("Expecting schedule parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSchedule(), schedule);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's schedule does not contain the given String elements in Collection.
     *
     * @param schedule the given elements that should not be in actual IndexerConfig's schedule.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's schedule contains any given String elements.
     */
    public S doesNotHaveSchedule(java.util.Collection<? extends String> schedule) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given String collection is not null.
        if (schedule == null) {
            failWithMessage("Expecting schedule parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSchedule(), schedule.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig has no schedule.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's schedule is not empty.
     */
    public S hasNoSchedule() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have schedule but had :\n  <%s>";

        // check
        if (actual.getSchedule().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getSchedule());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual IndexerConfig's score is equal to the given one.
     *
     * @param score the given score to compare the actual IndexerConfig's score to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's score is not equal to the given one.
     */
    public S hasScore(int score) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting score of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // check
        int actualScore = actual.getScore();
        if (actualScore != score) {
            failWithMessage(assertjErrorMessage, actual, score, actualScore);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's searchModuleType is equal to the given one.
     *
     * @param searchModuleType the given searchModuleType to compare the actual IndexerConfig's searchModuleType to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's searchModuleType is not equal to the given one.
     */
    public S hasSearchModuleType(SearchModuleType searchModuleType) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting searchModuleType of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        SearchModuleType actualSearchModuleType = actual.getSearchModuleType();
        if (!Objects.areEqual(actualSearchModuleType, searchModuleType)) {
            failWithMessage(assertjErrorMessage, actual, searchModuleType, actualSearchModuleType);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is show on search.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is not show on search.
     */
    public S isShowOnSearch() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is true
        if (!actual.isShowOnSearch()) {
            failWithMessage("\nExpecting that actual IndexerConfig is show on search but is not.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig is not show on search.
     *
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig is show on search.
     */
    public S isNotShowOnSearch() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that property call/field access is false
        if (actual.isShowOnSearch()) {
            failWithMessage("\nExpecting that actual IndexerConfig is not show on search but is.");
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's state is equal to the given one.
     *
     * @param state the given state to compare the actual IndexerConfig's state to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's state is not equal to the given one.
     */
    public S hasState(IndexerConfig.State state) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting state of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        IndexerConfig.State actualState = actual.getState();
        if (!Objects.areEqual(actualState, state)) {
            failWithMessage(assertjErrorMessage, actual, state, actualState);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchIds contains the given org.nzbhydra.config.mediainfo.MediaIdType elements.
     *
     * @param supportedSearchIds the given elements that should be contained in actual IndexerConfig's supportedSearchIds.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchIds does not contain all given org.nzbhydra.config.mediainfo.MediaIdType elements.
     */
    public S hasSupportedSearchIds(org.nzbhydra.config.mediainfo.MediaIdType... supportedSearchIds) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.mediainfo.MediaIdType varargs is not null.
        if (supportedSearchIds == null) {
            failWithMessage("Expecting supportedSearchIds parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSupportedSearchIds(), supportedSearchIds);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchIds contains the given org.nzbhydra.config.mediainfo.MediaIdType elements in Collection.
     *
     * @param supportedSearchIds the given elements that should be contained in actual IndexerConfig's supportedSearchIds.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchIds does not contain all given org.nzbhydra.config.mediainfo.MediaIdType elements.
     */
    public S hasSupportedSearchIds(java.util.Collection<? extends org.nzbhydra.config.mediainfo.MediaIdType> supportedSearchIds) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.mediainfo.MediaIdType collection is not null.
        if (supportedSearchIds == null) {
            failWithMessage("Expecting supportedSearchIds parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSupportedSearchIds(), supportedSearchIds.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchIds contains <b>only</b> the given org.nzbhydra.config.mediainfo.MediaIdType elements and nothing else in whatever order.
     *
     * @param supportedSearchIds the given elements that should be contained in actual IndexerConfig's supportedSearchIds.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchIds does not contain all given org.nzbhydra.config.mediainfo.MediaIdType elements.
     */
    public S hasOnlySupportedSearchIds(org.nzbhydra.config.mediainfo.MediaIdType... supportedSearchIds) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.mediainfo.MediaIdType varargs is not null.
        if (supportedSearchIds == null) {
            failWithMessage("Expecting supportedSearchIds parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSupportedSearchIds(), supportedSearchIds);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchIds contains <b>only</b> the given org.nzbhydra.config.mediainfo.MediaIdType elements in Collection and nothing else in whatever order.
     *
     * @param supportedSearchIds the given elements that should be contained in actual IndexerConfig's supportedSearchIds.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchIds does not contain all given org.nzbhydra.config.mediainfo.MediaIdType elements.
     */
    public S hasOnlySupportedSearchIds(java.util.Collection<? extends org.nzbhydra.config.mediainfo.MediaIdType> supportedSearchIds) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.mediainfo.MediaIdType collection is not null.
        if (supportedSearchIds == null) {
            failWithMessage("Expecting supportedSearchIds parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSupportedSearchIds(), supportedSearchIds.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchIds does not contain the given org.nzbhydra.config.mediainfo.MediaIdType elements.
     *
     * @param supportedSearchIds the given elements that should not be in actual IndexerConfig's supportedSearchIds.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchIds contains any given org.nzbhydra.config.mediainfo.MediaIdType elements.
     */
    public S doesNotHaveSupportedSearchIds(org.nzbhydra.config.mediainfo.MediaIdType... supportedSearchIds) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.mediainfo.MediaIdType varargs is not null.
        if (supportedSearchIds == null) {
            failWithMessage("Expecting supportedSearchIds parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSupportedSearchIds(), supportedSearchIds);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchIds does not contain the given org.nzbhydra.config.mediainfo.MediaIdType elements in Collection.
     *
     * @param supportedSearchIds the given elements that should not be in actual IndexerConfig's supportedSearchIds.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchIds contains any given org.nzbhydra.config.mediainfo.MediaIdType elements.
     */
    public S doesNotHaveSupportedSearchIds(java.util.Collection<? extends org.nzbhydra.config.mediainfo.MediaIdType> supportedSearchIds) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.config.mediainfo.MediaIdType collection is not null.
        if (supportedSearchIds == null) {
            failWithMessage("Expecting supportedSearchIds parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSupportedSearchIds(), supportedSearchIds.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig has no supportedSearchIds.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchIds is not empty.
     */
    public S hasNoSupportedSearchIds() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have supportedSearchIds but had :\n  <%s>";

        // check
        if (actual.getSupportedSearchIds().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getSupportedSearchIds());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual IndexerConfig's supportedSearchTypes contains the given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     *
     * @param supportedSearchTypes the given elements that should be contained in actual IndexerConfig's supportedSearchTypes.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchTypes does not contain all given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     */
    public S hasSupportedSearchTypes(org.nzbhydra.mapping.newznab.ActionAttribute... supportedSearchTypes) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.mapping.newznab.ActionAttribute varargs is not null.
        if (supportedSearchTypes == null) {
            failWithMessage("Expecting supportedSearchTypes parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSupportedSearchTypes(), supportedSearchTypes);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchTypes contains the given org.nzbhydra.mapping.newznab.ActionAttribute elements in Collection.
     *
     * @param supportedSearchTypes the given elements that should be contained in actual IndexerConfig's supportedSearchTypes.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchTypes does not contain all given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     */
    public S hasSupportedSearchTypes(java.util.Collection<? extends org.nzbhydra.mapping.newznab.ActionAttribute> supportedSearchTypes) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.mapping.newznab.ActionAttribute collection is not null.
        if (supportedSearchTypes == null) {
            failWithMessage("Expecting supportedSearchTypes parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContains(info, actual.getSupportedSearchTypes(), supportedSearchTypes.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchTypes contains <b>only</b> the given org.nzbhydra.mapping.newznab.ActionAttribute elements and nothing else in whatever order.
     *
     * @param supportedSearchTypes the given elements that should be contained in actual IndexerConfig's supportedSearchTypes.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchTypes does not contain all given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     */
    public S hasOnlySupportedSearchTypes(org.nzbhydra.mapping.newznab.ActionAttribute... supportedSearchTypes) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.mapping.newznab.ActionAttribute varargs is not null.
        if (supportedSearchTypes == null) {
            failWithMessage("Expecting supportedSearchTypes parameter not to be null.");
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSupportedSearchTypes(), supportedSearchTypes);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchTypes contains <b>only</b> the given org.nzbhydra.mapping.newznab.ActionAttribute elements in Collection and nothing else in whatever order.
     *
     * @param supportedSearchTypes the given elements that should be contained in actual IndexerConfig's supportedSearchTypes.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchTypes does not contain all given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     */
    public S hasOnlySupportedSearchTypes(java.util.Collection<? extends org.nzbhydra.mapping.newznab.ActionAttribute> supportedSearchTypes) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.mapping.newznab.ActionAttribute collection is not null.
        if (supportedSearchTypes == null) {
            failWithMessage("Expecting supportedSearchTypes parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
        Iterables.instance().assertContainsOnly(info, actual.getSupportedSearchTypes(), supportedSearchTypes.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchTypes does not contain the given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     *
     * @param supportedSearchTypes the given elements that should not be in actual IndexerConfig's supportedSearchTypes.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchTypes contains any given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     */
    public S doesNotHaveSupportedSearchTypes(org.nzbhydra.mapping.newznab.ActionAttribute... supportedSearchTypes) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.mapping.newznab.ActionAttribute varargs is not null.
        if (supportedSearchTypes == null) {
            failWithMessage("Expecting supportedSearchTypes parameter not to be null.");
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSupportedSearchTypes(), supportedSearchTypes);

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's supportedSearchTypes does not contain the given org.nzbhydra.mapping.newznab.ActionAttribute elements in Collection.
     *
     * @param supportedSearchTypes the given elements that should not be in actual IndexerConfig's supportedSearchTypes.
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchTypes contains any given org.nzbhydra.mapping.newznab.ActionAttribute elements.
     */
    public S doesNotHaveSupportedSearchTypes(java.util.Collection<? extends org.nzbhydra.mapping.newznab.ActionAttribute> supportedSearchTypes) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // check that given org.nzbhydra.mapping.newznab.ActionAttribute collection is not null.
        if (supportedSearchTypes == null) {
            failWithMessage("Expecting supportedSearchTypes parameter not to be null.");
            return myself; // to fool Eclipse "Null pointer access" warning on toArray.
        }

        // check with standard error message (use overridingErrorMessage before contains to set your own message).
        Iterables.instance().assertDoesNotContain(info, actual.getSupportedSearchTypes(), supportedSearchTypes.toArray());

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig has no supportedSearchTypes.
     *
     * @return this assertion object.
     * @throws AssertionError if the actual IndexerConfig's supportedSearchTypes is not empty.
     */
    public S hasNoSupportedSearchTypes() {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // we override the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have supportedSearchTypes but had :\n  <%s>";

        // check
        if (actual.getSupportedSearchTypes().iterator().hasNext()) {
            failWithMessage(assertjErrorMessage, actual, actual.getSupportedSearchTypes());
        }

        // return the current assertion for method chaining
        return myself;
    }


    /**
     * Verifies that the actual IndexerConfig's timeout is equal to the given one.
     *
     * @param timeout the given timeout to compare the actual IndexerConfig's timeout to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's timeout is not equal to the given one.
     */
    public S hasTimeout(java.util.Optional timeout) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting timeout of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualTimeout = actual.getTimeout();
        if (!Objects.areEqual(actualTimeout, timeout)) {
            failWithMessage(assertjErrorMessage, actual, timeout, actualTimeout);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's userAgent is equal to the given one.
     *
     * @param userAgent the given userAgent to compare the actual IndexerConfig's userAgent to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's userAgent is not equal to the given one.
     */
    public S hasUserAgent(java.util.Optional userAgent) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting userAgent of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualUserAgent = actual.getUserAgent();
        if (!Objects.areEqual(actualUserAgent, userAgent)) {
            failWithMessage(assertjErrorMessage, actual, userAgent, actualUserAgent);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's username is equal to the given one.
     *
     * @param username the given username to compare the actual IndexerConfig's username to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's username is not equal to the given one.
     */
    public S hasUsername(java.util.Optional username) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting username of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        java.util.Optional actualUsername = actual.getUsername();
        if (!Objects.areEqual(actualUsername, username)) {
            failWithMessage(assertjErrorMessage, actual, username, actualUsername);
        }

        // return the current assertion for method chaining
        return myself;
    }

    /**
     * Verifies that the actual IndexerConfig's vipExpirationDate is equal to the given one.
     *
     * @param vipExpirationDate the given vipExpirationDate to compare the actual IndexerConfig's vipExpirationDate to.
     * @return this assertion object.
     * @throws AssertionError - if the actual IndexerConfig's vipExpirationDate is not equal to the given one.
     */
    public S hasVipExpirationDate(String vipExpirationDate) {
        // check that actual IndexerConfig we want to make assertions on is not null.
        isNotNull();

        // overrides the default error message with a more explicit one
        String assertjErrorMessage = "\nExpecting vipExpirationDate of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

        // null safe check
        String actualVipExpirationDate = actual.getVipExpirationDate();
        if (!Objects.areEqual(actualVipExpirationDate, vipExpirationDate)) {
            failWithMessage(assertjErrorMessage, actual, vipExpirationDate, actualVipExpirationDate);
        }

        // return the current assertion for method chaining
        return myself;
    }

}
